{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! This is Yankun Motivation I built this website because I enjoy learning new stuff off work. I think it would be great to have a place that centralizes all my notes, could be accessed through Internet, so that it's for me to look up when necessary. And by building a website like this, it also helps the others who are also interesting in these topics. I might misunderstand some of the questions/topics/concepts. For any issues or corrections, please open an issue in the repository. Thanks you very much, and hope the content is helpful :) How I Generate the Website? I use the static website generator MkDocs , which is really easy to use and can be customized with Material for MkDocs . I also use the icons from icons8 , it provides a huge range of icons with great designs.","title":"Welcome!"},{"location":"#welcome","text":"This is Yankun","title":"Welcome!"},{"location":"#motivation","text":"I built this website because I enjoy learning new stuff off work. I think it would be great to have a place that centralizes all my notes, could be accessed through Internet, so that it's for me to look up when necessary. And by building a website like this, it also helps the others who are also interesting in these topics. I might misunderstand some of the questions/topics/concepts. For any issues or corrections, please open an issue in the repository. Thanks you very much, and hope the content is helpful :)","title":"Motivation"},{"location":"#how-i-generate-the-website","text":"I use the static website generator MkDocs , which is really easy to use and can be customized with Material for MkDocs . I also use the icons from icons8 , it provides a huge range of icons with great designs.","title":"How I Generate the Website?"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/","text":"S3 Security (Resource Policies & ACLs) S3 Static Hosting Normal access is via AWS APIs. This feature allows access via HTTP. Index and error documents are set (HTML file). Website endpoint is created. Custom domain via Route53, bucket name matters. Usage Offloading: put static media in S3. Out-of-band pages: have a static page to show some maintenance info. Pricing Data storage, per GB per month. Data transfer fee. Certain costs per 1000 operations. Object Versioning & MFA Delete Versioning lets you store multiple versions of objects within a bucket. Operations which would modified objects generate a new version. Enable/Disable/Suspend Versioning Versioning is on bucket level, it's turned off by default. Once versioning is turned on, it can't be turned off. After the versioning is turned on, you can suspend the versioning and turn it back to enabled later. Without Versioning Objects are identified by key (name), their id are set to null. With Versioning Ids are allocated to objects. When retrieving, latest version are returned by default. But can get specific version individually as well. When delete without giving version id, it just creates a new special version (delete marker) on top. To actually remove a version, you just specify the version id that you want to remove. MFA Delete Enabled in versioning configuration. MFA is required to change bucket versioning state. MFA is required to delete versions. Serial number (MFA) + Code passed with API calls. S3 Performance Optimization Upload objects with single PUT request Single data stream to S3 If the stream fails, the upload fails and requires full restart Speed & reliability is limited because there is only one stream Maximum object size of 5GB Upload objects with multiple PUT requests Objects are broken up into smaller pieces Minimum object size of 100MB to be able to turn on this feature The object can be split into a maximum of 10000 pieces, for each piece, it can range in size between 5MB and 5GB The last piece can be less than 5MB The whole upload can partially fail, just need to restart for that part Transfer rate equals to the sum of the speed of all parts S3 accelerated transfer S3 is public regional service, using the public Internet for data transfer is never an optimal solution . To improve the performance, we can use the network of AWS edge locations. Data get transferred to the edge locations first, and then send to the bucket via AWS network. This feature is off by default, to turn it on, bucket name cannot contain periods, it needs to be DNS compatiable in its naming. Encryption Encryption Approaches Encryption At Rest one entity involved e.g. encrypt data before writing to disk Encryption In Transit Multiple individuals or systems involved e.g. encrypted data before sending to others Encryption Concepts plaintext: unencrypted data, can be document, iamge, app, etc algorithm: methods that used to generate encrypted data from plaintext and key key: a token that is used to encrypt/decrypt data cyphertext: encrypted data Symmetric Encryption Encrypt & decrypt with the same key, however, distributing keys can be really tricky. Asymmetric Encryption Receiver distributes the public key, sender encrypts the plaintext with the public key. Only reciever can decrypt the cypher with its private key. Signing Encrypt the message with own private key and others can decrypt the message with corresponding public key. Normally used for identity verification. Steganography Steganography is the practice of concealing a message within another message or a physical object. In computing contexts, a computer file, message, image is consealed within another file, message, image. Key Management Service (KMS) Regional & public service Create, store and manage keys AWS managed/customer managed CMKs Support symmetric & asymmetric keys Cryptographic opertions (encrypt, decrypt and more) Keys never leaves KMS - It provides FIPS 140 - 2 (L2) Support aliases, which are also isolated to regions CMK - Customer Master Key CMK is logical, has ID, date, policy, desc & state backed by phsical key material generated or imported CMKs can be used for up to 4KB of data KMS and CMKs Data Encryption Keys (DEKs) DEKs are generated from CMK, used to decrypt/encrypt on data > 4KB. However, this is not part of the KMS, you or the other service need to do this. This is how it works, Generate plaintext version of DEK and cyphertext version of DEK. Encrypt the data using plaintext key & discard it. Store the encrypted key with the data. When decrypt, first decrypt the DEK with KMS. Decrypt the cypher text with the decrypted DEK, and discard the DEK afterwards. S3 basically generate a DEK for each object that needs to be encrypted. Object Encryption We are talking about encrypting objects, buckets aren't encrypted. There are two types of encryptions, Client-side encryption: Objects are encrypted on users side, users are responsible for managing the keys, performing encryption/decryption. AWS is not involved in the encryption. Server-side encryption: The user send the plaintext (to the other parties, it's still encrypted in transit, but s3 endpoint will receive plaintext) and the encryption happens on the server side. We mainly focus on server-side encryption. SSE-C Server-side encryption with customer provided keys. Users are responsible for managing keys. Users send object and key to s3 endpoint, on the server side, object is encrypted and a hash of the key is generated, then, the server writes the key hash and cyphertext to the storage, and discard the key. When fetch object, users provide the key to decrypt objects they want to fetch, the server will generate the hash and compare with the key hash stored in storage. SSE-S3 S3 endpoints handles encryption/decryption processes and key management, so there is no admin overhead. For each object, s3 generates an unqie key to encrypt the object, and encrypts the key with a master key, the encrypted object & key pair is kept in storage. It's not suitable if: you need to control & get access to keys you need to take control of key rotation you need role separation (different roles have different set of permissions) SSE-KMS Different from SSE-S3, an AWS managed CMK is generated in KMS to encrypt the keys. S3 is provided with a pair of DEKs, a plaintext and an encrypted versions, to encrypt the object. Instead of using AMS managed CMK, can also use customer CMK. It gives control ono the key management & key rotation. It makes role separation possible (S3 admin that has no access to KMS cannot see the content of the objects in S3). Bucket Default Encryption When uploading, can hae the header x-amz-server-side-encryption in request, to specify the encryption type, e.g. AMS256 -> SSE-S3 aws:kms -> SSE-KMS S3 Object Storage Class S3 Lifecycle Configuration S3 Replication S3 Presigned URLs S3 Select and Glacier Select S3 Events S3 Access Logs","title":"Simple Storage Service(S3)"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#s3-security-resource-policies-acls","text":"","title":"S3 Security (Resource Policies &amp; ACLs)"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#s3-static-hosting","text":"Normal access is via AWS APIs. This feature allows access via HTTP. Index and error documents are set (HTML file). Website endpoint is created. Custom domain via Route53, bucket name matters.","title":"S3 Static Hosting"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#usage","text":"Offloading: put static media in S3. Out-of-band pages: have a static page to show some maintenance info.","title":"Usage"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#pricing","text":"Data storage, per GB per month. Data transfer fee. Certain costs per 1000 operations.","title":"Pricing"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#object-versioning-mfa-delete","text":"Versioning lets you store multiple versions of objects within a bucket. Operations which would modified objects generate a new version.","title":"Object Versioning &amp; MFA Delete"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#enabledisablesuspend-versioning","text":"Versioning is on bucket level, it's turned off by default. Once versioning is turned on, it can't be turned off. After the versioning is turned on, you can suspend the versioning and turn it back to enabled later.","title":"Enable/Disable/Suspend Versioning"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#without-versioning","text":"Objects are identified by key (name), their id are set to null.","title":"Without Versioning"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#with-versioning","text":"Ids are allocated to objects. When retrieving, latest version are returned by default. But can get specific version individually as well. When delete without giving version id, it just creates a new special version (delete marker) on top. To actually remove a version, you just specify the version id that you want to remove.","title":"With Versioning"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#mfa-delete","text":"Enabled in versioning configuration. MFA is required to change bucket versioning state. MFA is required to delete versions. Serial number (MFA) + Code passed with API calls.","title":"MFA Delete"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#s3-performance-optimization","text":"","title":"S3 Performance Optimization"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#upload-objects-with-single-put-request","text":"Single data stream to S3 If the stream fails, the upload fails and requires full restart Speed & reliability is limited because there is only one stream Maximum object size of 5GB","title":"Upload objects with single PUT request"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#upload-objects-with-multiple-put-requests","text":"Objects are broken up into smaller pieces Minimum object size of 100MB to be able to turn on this feature The object can be split into a maximum of 10000 pieces, for each piece, it can range in size between 5MB and 5GB The last piece can be less than 5MB The whole upload can partially fail, just need to restart for that part Transfer rate equals to the sum of the speed of all parts","title":"Upload objects with multiple PUT requests"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#s3-accelerated-transfer","text":"S3 is public regional service, using the public Internet for data transfer is never an optimal solution . To improve the performance, we can use the network of AWS edge locations. Data get transferred to the edge locations first, and then send to the bucket via AWS network. This feature is off by default, to turn it on, bucket name cannot contain periods, it needs to be DNS compatiable in its naming.","title":"S3 accelerated transfer"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#encryption","text":"","title":"Encryption"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#encryption-approaches","text":"","title":"Encryption Approaches"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#encryption-at-rest","text":"one entity involved e.g. encrypt data before writing to disk","title":"Encryption At Rest"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#encryption-in-transit","text":"Multiple individuals or systems involved e.g. encrypted data before sending to others","title":"Encryption In Transit"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#encryption-concepts","text":"plaintext: unencrypted data, can be document, iamge, app, etc algorithm: methods that used to generate encrypted data from plaintext and key key: a token that is used to encrypt/decrypt data cyphertext: encrypted data","title":"Encryption Concepts"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#symmetric-encryption","text":"Encrypt & decrypt with the same key, however, distributing keys can be really tricky.","title":"Symmetric Encryption"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#asymmetric-encryption","text":"Receiver distributes the public key, sender encrypts the plaintext with the public key. Only reciever can decrypt the cypher with its private key.","title":"Asymmetric Encryption"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#signing","text":"Encrypt the message with own private key and others can decrypt the message with corresponding public key. Normally used for identity verification.","title":"Signing"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#steganography","text":"Steganography is the practice of concealing a message within another message or a physical object. In computing contexts, a computer file, message, image is consealed within another file, message, image.","title":"Steganography"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#key-management-service-kms","text":"Regional & public service Create, store and manage keys AWS managed/customer managed CMKs Support symmetric & asymmetric keys Cryptographic opertions (encrypt, decrypt and more) Keys never leaves KMS - It provides FIPS 140 - 2 (L2) Support aliases, which are also isolated to regions","title":"Key Management Service (KMS)"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#cmk-customer-master-key","text":"CMK is logical, has ID, date, policy, desc & state backed by phsical key material generated or imported CMKs can be used for up to 4KB of data","title":"CMK - Customer Master Key"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#kms-and-cmks","text":"","title":"KMS and CMKs"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#data-encryption-keys-deks","text":"DEKs are generated from CMK, used to decrypt/encrypt on data > 4KB. However, this is not part of the KMS, you or the other service need to do this. This is how it works, Generate plaintext version of DEK and cyphertext version of DEK. Encrypt the data using plaintext key & discard it. Store the encrypted key with the data. When decrypt, first decrypt the DEK with KMS. Decrypt the cypher text with the decrypted DEK, and discard the DEK afterwards. S3 basically generate a DEK for each object that needs to be encrypted.","title":"Data Encryption Keys (DEKs)"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#object-encryption","text":"We are talking about encrypting objects, buckets aren't encrypted. There are two types of encryptions, Client-side encryption: Objects are encrypted on users side, users are responsible for managing the keys, performing encryption/decryption. AWS is not involved in the encryption. Server-side encryption: The user send the plaintext (to the other parties, it's still encrypted in transit, but s3 endpoint will receive plaintext) and the encryption happens on the server side. We mainly focus on server-side encryption.","title":"Object Encryption"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#sse-c","text":"Server-side encryption with customer provided keys. Users are responsible for managing keys. Users send object and key to s3 endpoint, on the server side, object is encrypted and a hash of the key is generated, then, the server writes the key hash and cyphertext to the storage, and discard the key. When fetch object, users provide the key to decrypt objects they want to fetch, the server will generate the hash and compare with the key hash stored in storage.","title":"SSE-C"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#sse-s3","text":"S3 endpoints handles encryption/decryption processes and key management, so there is no admin overhead. For each object, s3 generates an unqie key to encrypt the object, and encrypts the key with a master key, the encrypted object & key pair is kept in storage. It's not suitable if: you need to control & get access to keys you need to take control of key rotation you need role separation (different roles have different set of permissions)","title":"SSE-S3"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#sse-kms","text":"Different from SSE-S3, an AWS managed CMK is generated in KMS to encrypt the keys. S3 is provided with a pair of DEKs, a plaintext and an encrypted versions, to encrypt the object. Instead of using AMS managed CMK, can also use customer CMK. It gives control ono the key management & key rotation. It makes role separation possible (S3 admin that has no access to KMS cannot see the content of the objects in S3).","title":"SSE-KMS"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#bucket-default-encryption","text":"When uploading, can hae the header x-amz-server-side-encryption in request, to specify the encryption type, e.g. AMS256 -> SSE-S3 aws:kms -> SSE-KMS","title":"Bucket Default Encryption"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#s3-object-storage-class","text":"","title":"S3 Object Storage Class"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#s3-lifecycle-configuration","text":"","title":"S3 Lifecycle Configuration"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#s3-replication","text":"","title":"S3 Replication"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#s3-presigned-urls","text":"","title":"S3 Presigned URLs"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#s3-select-and-glacier-select","text":"","title":"S3 Select and Glacier Select"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#s3-events","text":"","title":"S3 Events"},{"location":"AWS/Solution%20Architect%20Associate/Simple%20Storage%20Service%28S3%29/#s3-access-logs","text":"","title":"S3 Access Logs"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%202/","text":"Review Questions What are the modules of C++ programs called? Functions What does the following preprocessor directive do? #include <iostream> It links the source code and head file iostream . the contents of the head file will be added to the source code before compilation. What does the following statement do? using namespace std; It makes the definitions in std namespace available to the program. What statement would you use to print the phrase \u201cHello, world\u201d and then start a new line? using namespace std ; cout << \"Hello, world\" << endl ; What statement would you use to create an integer variable with the name cheeses? int cheeses ; What statement would you use to assign the value 32 to the variable cheeses? cheeses = 32 ; What statement would you use to assign the value read from keyboard to the variable cheeses? cin >> cheeses ; What statement would you use to print \"We have X varieties of cheese,\", where X is the value of the variable cheeses? cout << \"We have \" << cheeses << \" varieties of cheese,\" ; What do the function prototypes tell us about the functions? int froop(double t); void rattle(int n); int prune(void) int froop(double t); , the return type is int , function name is froop , it accepts one argument of type double . void rattle(int n); , the function has no return value, function name is rattle , it accepts one argument of type int . int prune(void) , the return type is int , function name is prune , it doesn't take any arguments. When is return not needed when you defining a function? When the function has no return value. When you are writing main function and want to return 0 . When you are writing main function, it has the statement cout << \"Please enter your PIN: \"; . The compiler says cout is an undeclared identifier. What is the cause of the issue? How can it be solved? The issue is caused because we don't specify the namespace where cout is defined. To solve the issue, we could, 1. add using namespace std; 2. add using std::cout; 3. change it to std::cout << \"Please enter your PIN: \"; Coding Exercise 2.1 #include <iostream> /* * Write a C++ program that displays your name * and address (or if you value your privacy, * a fictitious name and address). */ int main () { using namespace std ; cout << \"Lionel Messi\" << endl ; cout << \"12 Abc St, Sydney, NSW, 2000\" << endl ; return 0 ; } 2.2 #include <iostream> int furlongToYard ( int furlong ) { return furlong * 220 ; } /* * Write a C++ program that asks for a distance * in furlongs and converts it to yards. (One * furlong is 220 yards.) */ int main () { using namespace std ; int furlongs ; cout << \"Enter furlongs: \" ; cin >> furlongs ; cout << \"Yards: \" << furlongToYard ( furlongs ) << endl ; return 0 ; } 2.3 #include <iostream> using namespace std ; void printFirstTwoLines () { for ( int i = 0 ; i < 2 ; i ++ ) { cout << \"Three blind mice\" << endl ; } } void printLastTwoLines () { for ( int i = 0 ; i < 2 ; i ++ ) { cout << \"See how they run\" << endl ; } } /* * Write a C++ program that uses three user-defined * functions (counting main() as one) and produces * the following output: * * Three blind mice * Three blind mice * See how they run * See how they run * * One function, called two times, should produce * the first two lines, and the remaining function, * also called twice, should produce the remaining * output. */ int main () { printFirstTwoLines (); printLastTwoLines (); return 0 ; } 2.4 #include <iostream> int yearToMonth ( int year ) { return year * 12 ; } /* * Write a program that asks the user to enter * his or her age. The program then should * display the age in months: * * Enter your age: 29 * Your age in months is 348. */ int main () { using namespace std ; cout << \"Enter your age: \" ; int age ; cin >> age ; cout << \"Your age in months is \" << yearToMonth ( age ) << '.' << endl ; return 0 ; } 2.5 #include <iostream> double celsiusToFahrenheit ( double celsius ) { return 1.8 * celsius + 32 ; } /* * Write a program that has main() call a user-defined * function that takes a Celsius temperature value as an * argument and then returns the equivalent Fahrenheit * value. The program should request the Celsius value * as input from the user and display the result, as shown * in the following code: * * Please enter a Celsius value: 20 * 20 degrees Celsius is 68 degrees Fahrenheit. * * For reference, here is the formula for making the * conversion: * * Fahrenheit = 1.8 \u00d7 degrees Celsius + 32.0 */ int main () { using namespace std ; cout << \"Please enter a Celsius value: \" ; double celsius ; cin >> celsius ; cout << celsius << \" degrees Celsius is \" << celsiusToFahrenheit ( celsius ) << \" degrees Fahrenheit.\" << endl ; return 0 ; } 2.6 #include <iostream> double convert ( double lightYear ) { return lightYear * 63240 ; } /* * Write a program that has main() call a user-defined * function that takes a distance in light years as an * argument and then returns the distance in astronomical * units. The program should request the light year value * as input from the user and display the result, as shown * in the following code: * * Enter the number of light years: 4.2 * 4.2 light years = 265608 astronomical units. * * An astronomical unit is the average distance from the * earth to the sun (about 150,000,000 km or 93,000,000 * miles), and a light year is the distance light travels * in a year (about 10 trillion kilometers or 6 trillion * miles). (The nearest star after the sun is about 4.2 * light years away.) Use type double (as in Listing 2.4) * and this conversion factor: * * 1 light year = 63,240 astronomical units */ int main () { using namespace std ; cout << \"Enter the number of light years: \" ; double lightYears ; cin >> lightYears ; cout << lightYears << \" light years = \" << convert ( lightYears ) << \" astronomical units.\" << endl ; return 0 ; } 2.7 #include <iostream> using namespace std ; void printTime ( int hours , int minutes ) { cout << \"Time: \" << hours << \":\" << minutes << endl ; } /* * Write a program that asks the user to enter * an hour value and a minute value. The main() * function should then pass these two values * to a type void function that displays the two * values in the format shown in the following * sample run: * * Enter the number of hours: 9 * Enter the number of minutes: 28 * Time: 9:28 */ int main () { cout << \"Enter the number of hours: \" ; int hours ; cin >> hours ; cout << \"Enter the number of minutes: \" ; int minutes ; cin >> minutes ; printTime ( hours , minutes ); return 0 ; }","title":"Chapter 2"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%202/#review-questions","text":"What are the modules of C++ programs called? Functions What does the following preprocessor directive do? #include <iostream> It links the source code and head file iostream . the contents of the head file will be added to the source code before compilation. What does the following statement do? using namespace std; It makes the definitions in std namespace available to the program. What statement would you use to print the phrase \u201cHello, world\u201d and then start a new line? using namespace std ; cout << \"Hello, world\" << endl ; What statement would you use to create an integer variable with the name cheeses? int cheeses ; What statement would you use to assign the value 32 to the variable cheeses? cheeses = 32 ; What statement would you use to assign the value read from keyboard to the variable cheeses? cin >> cheeses ; What statement would you use to print \"We have X varieties of cheese,\", where X is the value of the variable cheeses? cout << \"We have \" << cheeses << \" varieties of cheese,\" ; What do the function prototypes tell us about the functions? int froop(double t); void rattle(int n); int prune(void) int froop(double t); , the return type is int , function name is froop , it accepts one argument of type double . void rattle(int n); , the function has no return value, function name is rattle , it accepts one argument of type int . int prune(void) , the return type is int , function name is prune , it doesn't take any arguments. When is return not needed when you defining a function? When the function has no return value. When you are writing main function and want to return 0 . When you are writing main function, it has the statement cout << \"Please enter your PIN: \"; . The compiler says cout is an undeclared identifier. What is the cause of the issue? How can it be solved? The issue is caused because we don't specify the namespace where cout is defined. To solve the issue, we could, 1. add using namespace std; 2. add using std::cout; 3. change it to std::cout << \"Please enter your PIN: \";","title":"Review Questions"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%202/#coding-exercise","text":"","title":"Coding Exercise"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%202/#21","text":"#include <iostream> /* * Write a C++ program that displays your name * and address (or if you value your privacy, * a fictitious name and address). */ int main () { using namespace std ; cout << \"Lionel Messi\" << endl ; cout << \"12 Abc St, Sydney, NSW, 2000\" << endl ; return 0 ; }","title":"2.1"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%202/#22","text":"#include <iostream> int furlongToYard ( int furlong ) { return furlong * 220 ; } /* * Write a C++ program that asks for a distance * in furlongs and converts it to yards. (One * furlong is 220 yards.) */ int main () { using namespace std ; int furlongs ; cout << \"Enter furlongs: \" ; cin >> furlongs ; cout << \"Yards: \" << furlongToYard ( furlongs ) << endl ; return 0 ; }","title":"2.2"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%202/#23","text":"#include <iostream> using namespace std ; void printFirstTwoLines () { for ( int i = 0 ; i < 2 ; i ++ ) { cout << \"Three blind mice\" << endl ; } } void printLastTwoLines () { for ( int i = 0 ; i < 2 ; i ++ ) { cout << \"See how they run\" << endl ; } } /* * Write a C++ program that uses three user-defined * functions (counting main() as one) and produces * the following output: * * Three blind mice * Three blind mice * See how they run * See how they run * * One function, called two times, should produce * the first two lines, and the remaining function, * also called twice, should produce the remaining * output. */ int main () { printFirstTwoLines (); printLastTwoLines (); return 0 ; }","title":"2.3"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%202/#24","text":"#include <iostream> int yearToMonth ( int year ) { return year * 12 ; } /* * Write a program that asks the user to enter * his or her age. The program then should * display the age in months: * * Enter your age: 29 * Your age in months is 348. */ int main () { using namespace std ; cout << \"Enter your age: \" ; int age ; cin >> age ; cout << \"Your age in months is \" << yearToMonth ( age ) << '.' << endl ; return 0 ; }","title":"2.4"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%202/#25","text":"#include <iostream> double celsiusToFahrenheit ( double celsius ) { return 1.8 * celsius + 32 ; } /* * Write a program that has main() call a user-defined * function that takes a Celsius temperature value as an * argument and then returns the equivalent Fahrenheit * value. The program should request the Celsius value * as input from the user and display the result, as shown * in the following code: * * Please enter a Celsius value: 20 * 20 degrees Celsius is 68 degrees Fahrenheit. * * For reference, here is the formula for making the * conversion: * * Fahrenheit = 1.8 \u00d7 degrees Celsius + 32.0 */ int main () { using namespace std ; cout << \"Please enter a Celsius value: \" ; double celsius ; cin >> celsius ; cout << celsius << \" degrees Celsius is \" << celsiusToFahrenheit ( celsius ) << \" degrees Fahrenheit.\" << endl ; return 0 ; }","title":"2.5"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%202/#26","text":"#include <iostream> double convert ( double lightYear ) { return lightYear * 63240 ; } /* * Write a program that has main() call a user-defined * function that takes a distance in light years as an * argument and then returns the distance in astronomical * units. The program should request the light year value * as input from the user and display the result, as shown * in the following code: * * Enter the number of light years: 4.2 * 4.2 light years = 265608 astronomical units. * * An astronomical unit is the average distance from the * earth to the sun (about 150,000,000 km or 93,000,000 * miles), and a light year is the distance light travels * in a year (about 10 trillion kilometers or 6 trillion * miles). (The nearest star after the sun is about 4.2 * light years away.) Use type double (as in Listing 2.4) * and this conversion factor: * * 1 light year = 63,240 astronomical units */ int main () { using namespace std ; cout << \"Enter the number of light years: \" ; double lightYears ; cin >> lightYears ; cout << lightYears << \" light years = \" << convert ( lightYears ) << \" astronomical units.\" << endl ; return 0 ; }","title":"2.6"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%202/#27","text":"#include <iostream> using namespace std ; void printTime ( int hours , int minutes ) { cout << \"Time: \" << hours << \":\" << minutes << endl ; } /* * Write a program that asks the user to enter * an hour value and a minute value. The main() * function should then pass these two values * to a type void function that displays the two * values in the format shown in the following * sample run: * * Enter the number of hours: 9 * Enter the number of minutes: 28 * Time: 9:28 */ int main () { cout << \"Enter the number of hours: \" ; int hours ; cin >> hours ; cout << \"Enter the number of minutes: \" ; int minutes ; cin >> minutes ; printTime ( hours , minutes ); return 0 ; }","title":"2.7"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%203/","text":"Review Questions Why C++ has different types for integers? Different integer types have different ranges, thus take different memory space. Having these different types provides us flexibility when writing code. Declare variables as stated below: a. short type integer, with value 80 short val = 80; b. unsigned int type integer, with value 42110 unsigned int val = 42110; c. integer with value 3000000000 long val = 3000000000; How does C++ prevent the integers from being out of ranges? When the integer value already reaches the upper bound of the range, increasing by one would make the integer value equal to the lower bound of the range. What's the difference between 33L and 33 ? By default, 33 is of type int , 33L is of type long . Are these two statements equivalent? `char grade = 65; `char grade = 'A'; Yes, they are equivalent. How to find the character with ASC II equals to 88? List at least 2 methods. char ch = 88; char ch = (char) 88; Assigning long to float would cause loss of precision, how about assigning long to double? assigning long long to double? Assigning long and long long to double is fine. What's the value of these statements 8 * 9 + 2 74 6 * 3 / 4 4 3 / 4 * 6 0 6.0 * 3 / 4 4.5 15 % 4 3 Assume that x1 and x2 are two double type variables, you need to convert them to integers and calculate the sum, assign the result to an integer variable. What if we want to calculate the sum and then convert. convertion first int sum = int (x1) + int (x2); convertion later int sum = int (x1 + x2) What are the types of these variables for the declaration statements below, auto cars = 15; int auto iou = 150.37; double auto level = 'B'; char auto crat = U'/U00002155'; w_chart auto fract = 8.25f/2.5; double Coding Exercise 3.1 #include <iostream> using namespace std ; /** * Write a short program that asks for your height * in integer inches and then converts your height * to feet and inches. Have the program use the * underscore character to indicate where to type * the response. Also use a const symbolic constant * to represent the conversion factor. */ int main () { int height ; const int INCHES_PER_FOOT = 12 ; cout << \"Please input your height in inches: \" ; cin >> height ; int feet = height / INCHES_PER_FOOT ; int inches = height % INCHES_PER_FOOT ; cout << \"Your height is \" << feet << \" feet and \" << inches << \" inches.\" << endl ; return 0 ; } 3.2 #include <iostream> using namespace std ; /** * Write a short program that asks for your height in feet and inches and your * weight in pounds. (Use three variables to store the information.) Have the * program report your body mass index (BMI). To calculate the BMI, first * convert your height in feet and inches to your height in inches * (1 foot = 12 inches). Then convert your height in inches to your height in * meters by multiplying by 0.0254. Then convert your weight in pounds into * your mass in kilograms by dividing by 2.2. Finally, compute your BMI by * dividing your mass in kilograms by the square of your height in meters. Use * symbolic constants to represent the various conversion factors. */ int main () { int heightFeet , heightInches , weightPounds ; const int INCHES_PER_FOOT = 12 ; const double METERS_PER_INCH = 0.0254 ; const double POUNDS_PER_KILOGRAMS = 2.2 ; cout << \"Please input your height in feet and inches: \" ; cin >> heightFeet >> heightInches ; cout << \"Please input your weight in pounds: \" ; cin >> weightPounds ; int heightInInches = heightFeet * INCHES_PER_FOOT + heightInches ; double heightInMeters = heightInInches * METERS_PER_INCH ; double weightInKilograms = weightPounds / POUNDS_PER_KILOGRAMS ; double bmiIndex = weightInKilograms / ( heightInMeters * heightInMeters ); cout << \"The BMI index is: \" << bmiIndex << endl ; return 0 ; } 3.3 #include <iostream> using namespace std ; /** * Write a program that asks the user to enter a latitude in degrees, minutes, * and seconds and that then displays the latitude in decimal format. There are * 60 seconds of arc to a minute and 60 minutes of arc to a degree; represent * these values with symbolic constants. You should use a separate variable for * each input value. A sample run should look like this: * * Enter a latitude in degrees, minutes, and seconds: * First, enter the degrees: 37 * Next, enter the minutes of arc: 51 * Finally, enter the seconds of arc: 19 * * 37 degrees, 51 minutes, 19 seconds = 37.8553 degrees */ int main () { const double SECONDS_PER_MINUTE = 60.0 ; const double MINUTES_PER_DEGREE = 60.0 ; int degree , minute , second ; cout << \"Enter a latitude in degrees, minutes, and seconds:\" << endl ; cout << \"First, enter the degrees: \" ; cin >> degree ; cout << \"Next, enter the minutes of arc: \" ; cin >> minute ; cout << \"Finally, enter the seconds of arc: \" ; cin >> second ; double degrees = degree + ( minute + second / SECONDS_PER_MINUTE ) / MINUTES_PER_DEGREE ; cout << degree << \" degrees, \" << minute << \" minutes, \" << second << \" seconds = \" << degrees << \" degrees\" << endl ; return 0 ; } 3.4 #include <iostream> using namespace std ; /** * Write a program that asks the user to enter the number of seconds as an * integer value (use type long, or, if available, long long) and that then * displays the equivalent time in days, hours, minutes, and seconds. Use * symbolic constants to represent the number of hours in the day, the number * of minutes in an hour, and the number of seconds in a minute. The output * should look like this: * * Enter the number of seconds: 31600000 * 31600000 seconds = 365 days, 17 hours, 46 minutes, 40 seconds */ int main () { const int SECONDS_PER_MINUTE = 60 ; const int SECONDS_PER_HOURS = 60 * SECONDS_PER_MINUTE ; const int SECONDS_PER_DAY = 24 * SECONDS_PER_HOURS ; long long totalSeconds ; int days , hours , minutes , seconds , secondsLeft ; cout << \"Enter the number of seconds: \" ; cin >> totalSeconds ; // calculate days days = totalSeconds / SECONDS_PER_DAY ; secondsLeft = totalSeconds % SECONDS_PER_DAY ; // calculate hours hours = secondsLeft / SECONDS_PER_HOURS ; secondsLeft %= SECONDS_PER_HOURS ; // calculate minutes minutes = secondsLeft / SECONDS_PER_MINUTE ; seconds = secondsLeft % SECONDS_PER_MINUTE ; cout << totalSeconds << \" seconds = \" << days << \" days, \" << hours << \" hours, \" << minutes << \" minutes, \" << seconds << \" seconds\" << endl ; return 0 ; } 3.5 #include <iostream> using namespace std ; /** * Write a program that requests the user to enter the current world population * and the current population of the U.S. (or of some other nation of your * choice). Store the information in variables of type long long. Have the * program display the percent that the U.S. (or other nation\u2019s) population is * of the world\u2019s population. The output should look something like this: * * Enter the world's population: 6898758899 * Enter the population of the US: 310783781 * The population of the US is 4.50492% of the world population. * * You can use the Internet to get more recent figures. */ int main () { long long usaPopulation , worldPopulation ; cout << \"Enter the world's population: \" ; cin >> worldPopulation ; cout << \"Enter the population of the US: \" ; cin >> usaPopulation ; cout << \"The population of the US is \" << usaPopulation * 100.0 / worldPopulation << \"% of the world population.\" << endl ; return 0 ; } 3.6 #include <iostream> using namespace std ; /** * Write a program that asks how many miles you have driven and how many * gallons of gasoline you have used and then reports the miles per gallon your * car has gotten. Or, if you prefer, the program can request distance in * kilometers and petrol in liters and then report the result European style, * in liters per 100 kilometers. */ int main () { double distanceTraveled , petrolUsed ; cout << \"Enter the distance traveled in kilometers: \" ; cin >> distanceTraveled ; cout << \"Enter the petrol has been used in liters: \" ; cin >> petrolUsed ; cout << \"On average, you need \" << petrolUsed / distanceTraveled * 100 << \" liters petrol per 100 kilometers.\" << endl ; return 0 ; } 3.7 #include <iostream> using namespace std ; /** * Write a program that asks you to enter an automobile gasoline consumption * figure in the European style (liters per 100 kilometers) and converts to the * U.S. style of miles per gallon. Note that in addition to using different * units of measurement, the U.S. approach (distance / fuel) is the inverse of * the European approach (fuel / distance). Note that 100 kilometers is * 62.14 miles, and 1 gallon is 3.875 liters. Thus, 19 mpg is about * 12.4 l/100 km, and 27 mpg is about 8.7 l/100 km. */ int main () { double euroStyleConsumption ; const double LITERS_PER_GALLON = 3.875 ; const double MILES_PER_HUNDRID_KMS = 62.14 ; cout << \"Enter an automobile gasoline consumption in European style (L/100Km): \" ; cin >> euroStypeConsumption ; double litersPerMile = euroStypeConsumption / MILES_PER_HUNDRID_KMS ; double gallonsPerMile = litersPerMile / LITERS_PER_GALLON ; cout << \"The U.S. approach (miles/gallon): \" << 1 / gallonsPerMile << endl ; return 0 ; }","title":"Chapter 3"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%203/#review-questions","text":"Why C++ has different types for integers? Different integer types have different ranges, thus take different memory space. Having these different types provides us flexibility when writing code. Declare variables as stated below: a. short type integer, with value 80 short val = 80; b. unsigned int type integer, with value 42110 unsigned int val = 42110; c. integer with value 3000000000 long val = 3000000000; How does C++ prevent the integers from being out of ranges? When the integer value already reaches the upper bound of the range, increasing by one would make the integer value equal to the lower bound of the range. What's the difference between 33L and 33 ? By default, 33 is of type int , 33L is of type long . Are these two statements equivalent? `char grade = 65; `char grade = 'A'; Yes, they are equivalent. How to find the character with ASC II equals to 88? List at least 2 methods. char ch = 88; char ch = (char) 88; Assigning long to float would cause loss of precision, how about assigning long to double? assigning long long to double? Assigning long and long long to double is fine. What's the value of these statements 8 * 9 + 2 74 6 * 3 / 4 4 3 / 4 * 6 0 6.0 * 3 / 4 4.5 15 % 4 3 Assume that x1 and x2 are two double type variables, you need to convert them to integers and calculate the sum, assign the result to an integer variable. What if we want to calculate the sum and then convert. convertion first int sum = int (x1) + int (x2); convertion later int sum = int (x1 + x2) What are the types of these variables for the declaration statements below, auto cars = 15; int auto iou = 150.37; double auto level = 'B'; char auto crat = U'/U00002155'; w_chart auto fract = 8.25f/2.5; double","title":"Review Questions"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%203/#coding-exercise","text":"","title":"Coding Exercise"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%203/#31","text":"#include <iostream> using namespace std ; /** * Write a short program that asks for your height * in integer inches and then converts your height * to feet and inches. Have the program use the * underscore character to indicate where to type * the response. Also use a const symbolic constant * to represent the conversion factor. */ int main () { int height ; const int INCHES_PER_FOOT = 12 ; cout << \"Please input your height in inches: \" ; cin >> height ; int feet = height / INCHES_PER_FOOT ; int inches = height % INCHES_PER_FOOT ; cout << \"Your height is \" << feet << \" feet and \" << inches << \" inches.\" << endl ; return 0 ; }","title":"3.1"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%203/#32","text":"#include <iostream> using namespace std ; /** * Write a short program that asks for your height in feet and inches and your * weight in pounds. (Use three variables to store the information.) Have the * program report your body mass index (BMI). To calculate the BMI, first * convert your height in feet and inches to your height in inches * (1 foot = 12 inches). Then convert your height in inches to your height in * meters by multiplying by 0.0254. Then convert your weight in pounds into * your mass in kilograms by dividing by 2.2. Finally, compute your BMI by * dividing your mass in kilograms by the square of your height in meters. Use * symbolic constants to represent the various conversion factors. */ int main () { int heightFeet , heightInches , weightPounds ; const int INCHES_PER_FOOT = 12 ; const double METERS_PER_INCH = 0.0254 ; const double POUNDS_PER_KILOGRAMS = 2.2 ; cout << \"Please input your height in feet and inches: \" ; cin >> heightFeet >> heightInches ; cout << \"Please input your weight in pounds: \" ; cin >> weightPounds ; int heightInInches = heightFeet * INCHES_PER_FOOT + heightInches ; double heightInMeters = heightInInches * METERS_PER_INCH ; double weightInKilograms = weightPounds / POUNDS_PER_KILOGRAMS ; double bmiIndex = weightInKilograms / ( heightInMeters * heightInMeters ); cout << \"The BMI index is: \" << bmiIndex << endl ; return 0 ; }","title":"3.2"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%203/#33","text":"#include <iostream> using namespace std ; /** * Write a program that asks the user to enter a latitude in degrees, minutes, * and seconds and that then displays the latitude in decimal format. There are * 60 seconds of arc to a minute and 60 minutes of arc to a degree; represent * these values with symbolic constants. You should use a separate variable for * each input value. A sample run should look like this: * * Enter a latitude in degrees, minutes, and seconds: * First, enter the degrees: 37 * Next, enter the minutes of arc: 51 * Finally, enter the seconds of arc: 19 * * 37 degrees, 51 minutes, 19 seconds = 37.8553 degrees */ int main () { const double SECONDS_PER_MINUTE = 60.0 ; const double MINUTES_PER_DEGREE = 60.0 ; int degree , minute , second ; cout << \"Enter a latitude in degrees, minutes, and seconds:\" << endl ; cout << \"First, enter the degrees: \" ; cin >> degree ; cout << \"Next, enter the minutes of arc: \" ; cin >> minute ; cout << \"Finally, enter the seconds of arc: \" ; cin >> second ; double degrees = degree + ( minute + second / SECONDS_PER_MINUTE ) / MINUTES_PER_DEGREE ; cout << degree << \" degrees, \" << minute << \" minutes, \" << second << \" seconds = \" << degrees << \" degrees\" << endl ; return 0 ; }","title":"3.3"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%203/#34","text":"#include <iostream> using namespace std ; /** * Write a program that asks the user to enter the number of seconds as an * integer value (use type long, or, if available, long long) and that then * displays the equivalent time in days, hours, minutes, and seconds. Use * symbolic constants to represent the number of hours in the day, the number * of minutes in an hour, and the number of seconds in a minute. The output * should look like this: * * Enter the number of seconds: 31600000 * 31600000 seconds = 365 days, 17 hours, 46 minutes, 40 seconds */ int main () { const int SECONDS_PER_MINUTE = 60 ; const int SECONDS_PER_HOURS = 60 * SECONDS_PER_MINUTE ; const int SECONDS_PER_DAY = 24 * SECONDS_PER_HOURS ; long long totalSeconds ; int days , hours , minutes , seconds , secondsLeft ; cout << \"Enter the number of seconds: \" ; cin >> totalSeconds ; // calculate days days = totalSeconds / SECONDS_PER_DAY ; secondsLeft = totalSeconds % SECONDS_PER_DAY ; // calculate hours hours = secondsLeft / SECONDS_PER_HOURS ; secondsLeft %= SECONDS_PER_HOURS ; // calculate minutes minutes = secondsLeft / SECONDS_PER_MINUTE ; seconds = secondsLeft % SECONDS_PER_MINUTE ; cout << totalSeconds << \" seconds = \" << days << \" days, \" << hours << \" hours, \" << minutes << \" minutes, \" << seconds << \" seconds\" << endl ; return 0 ; }","title":"3.4"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%203/#35","text":"#include <iostream> using namespace std ; /** * Write a program that requests the user to enter the current world population * and the current population of the U.S. (or of some other nation of your * choice). Store the information in variables of type long long. Have the * program display the percent that the U.S. (or other nation\u2019s) population is * of the world\u2019s population. The output should look something like this: * * Enter the world's population: 6898758899 * Enter the population of the US: 310783781 * The population of the US is 4.50492% of the world population. * * You can use the Internet to get more recent figures. */ int main () { long long usaPopulation , worldPopulation ; cout << \"Enter the world's population: \" ; cin >> worldPopulation ; cout << \"Enter the population of the US: \" ; cin >> usaPopulation ; cout << \"The population of the US is \" << usaPopulation * 100.0 / worldPopulation << \"% of the world population.\" << endl ; return 0 ; }","title":"3.5"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%203/#36","text":"#include <iostream> using namespace std ; /** * Write a program that asks how many miles you have driven and how many * gallons of gasoline you have used and then reports the miles per gallon your * car has gotten. Or, if you prefer, the program can request distance in * kilometers and petrol in liters and then report the result European style, * in liters per 100 kilometers. */ int main () { double distanceTraveled , petrolUsed ; cout << \"Enter the distance traveled in kilometers: \" ; cin >> distanceTraveled ; cout << \"Enter the petrol has been used in liters: \" ; cin >> petrolUsed ; cout << \"On average, you need \" << petrolUsed / distanceTraveled * 100 << \" liters petrol per 100 kilometers.\" << endl ; return 0 ; }","title":"3.6"},{"location":"C%2B%2B%20Primer%20Plus%20Solutions/Chapter%203/#37","text":"#include <iostream> using namespace std ; /** * Write a program that asks you to enter an automobile gasoline consumption * figure in the European style (liters per 100 kilometers) and converts to the * U.S. style of miles per gallon. Note that in addition to using different * units of measurement, the U.S. approach (distance / fuel) is the inverse of * the European approach (fuel / distance). Note that 100 kilometers is * 62.14 miles, and 1 gallon is 3.875 liters. Thus, 19 mpg is about * 12.4 l/100 km, and 27 mpg is about 8.7 l/100 km. */ int main () { double euroStyleConsumption ; const double LITERS_PER_GALLON = 3.875 ; const double MILES_PER_HUNDRID_KMS = 62.14 ; cout << \"Enter an automobile gasoline consumption in European style (L/100Km): \" ; cin >> euroStypeConsumption ; double litersPerMile = euroStypeConsumption / MILES_PER_HUNDRID_KMS ; double gallonsPerMile = litersPerMile / LITERS_PER_GALLON ; cout << \"The U.S. approach (miles/gallon): \" << 1 / gallonsPerMile << endl ; return 0 ; }","title":"3.7"},{"location":"Leetcode/Array/1.%20Two%20Sum/","text":"Question Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Ideas one idea is pre-sort the array, and for each number num , we just do binary search on the rest of the array, look for target - num . However, sorting the array requires O(nlogn) time, and it needs extra O(n) memory to keep the index mapping before/after the sorting as the question is asking for index pair. another idea is taking the advantages of hash. While scanning the array, we use a dictionary to keep a number - index mapping, and at the same time, look up target - number in the dictionary. It can stop early once we find the number pair. We need O(n) memory to keep the dictionary, and time complexity is also O(n) since it only requires a single scan. Solution class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: num_set = dict () for idx , num in enumerate ( nums ): if target - num in num_set : return [ idx , num_set [ target - num ]] # put this after the dict lookup, to avoid the # situation where num equals to target - num num_set [ num ] = idx # shouldn't reach here return [ - 1 , - 1 ]","title":"1. Two Sum"},{"location":"Leetcode/Array/1.%20Two%20Sum/#question","text":"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.","title":"Question"},{"location":"Leetcode/Array/1.%20Two%20Sum/#ideas","text":"one idea is pre-sort the array, and for each number num , we just do binary search on the rest of the array, look for target - num . However, sorting the array requires O(nlogn) time, and it needs extra O(n) memory to keep the index mapping before/after the sorting as the question is asking for index pair. another idea is taking the advantages of hash. While scanning the array, we use a dictionary to keep a number - index mapping, and at the same time, look up target - number in the dictionary. It can stop early once we find the number pair. We need O(n) memory to keep the dictionary, and time complexity is also O(n) since it only requires a single scan.","title":"Ideas"},{"location":"Leetcode/Array/1.%20Two%20Sum/#solution","text":"class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: num_set = dict () for idx , num in enumerate ( nums ): if target - num in num_set : return [ idx , num_set [ target - num ]] # put this after the dict lookup, to avoid the # situation where num equals to target - num num_set [ num ] = idx # shouldn't reach here return [ - 1 , - 1 ]","title":"Solution"},{"location":"Leetcode/Array/665.%20Non-decreasing%20Array/","text":"Question Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element. We define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2) . Ideas Just scan the array, when we see some pattern nums[i] > nums[i + 1] , if this is not the first time we see this pattern, return False because we can modify at most one number set nums[i] = nums[i + 1] if nums[i - 1] <= nums[i + 1] set nums[i + 1] = nums[i] if nums[i - 1] > nums[i + 1] The time complexity and space complexity are O(n) and O(1) . Solution class Solution : def checkPossibility ( self , nums : List [ int ]) -> bool : prev = float ( '-inf' ) changed = False for idx in range ( len ( nums ) - 1 ): if nums [ idx ] > nums [ idx + 1 ]: if changed : return False if nums [ idx + 1 ] >= prev : nums [ idx ] = nums [ idx + 1 ] else : nums [ idx + 1 ] = nums [ idx ] changed = True prev = nums [ idx ] return True","title":"665. Non decreasing Array"},{"location":"Leetcode/Array/665.%20Non-decreasing%20Array/#question","text":"Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element. We define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2) .","title":"Question"},{"location":"Leetcode/Array/665.%20Non-decreasing%20Array/#ideas","text":"Just scan the array, when we see some pattern nums[i] > nums[i + 1] , if this is not the first time we see this pattern, return False because we can modify at most one number set nums[i] = nums[i + 1] if nums[i - 1] <= nums[i + 1] set nums[i + 1] = nums[i] if nums[i - 1] > nums[i + 1] The time complexity and space complexity are O(n) and O(1) .","title":"Ideas"},{"location":"Leetcode/Array/665.%20Non-decreasing%20Array/#solution","text":"class Solution : def checkPossibility ( self , nums : List [ int ]) -> bool : prev = float ( '-inf' ) changed = False for idx in range ( len ( nums ) - 1 ): if nums [ idx ] > nums [ idx + 1 ]: if changed : return False if nums [ idx + 1 ] >= prev : nums [ idx ] = nums [ idx + 1 ] else : nums [ idx + 1 ] = nums [ idx ] changed = True prev = nums [ idx ] return True","title":"Solution"},{"location":"Leetcode/Data%20Structure/460.%20LFU%20Cache/","text":"Question Design and implement a data structure for a Least Frequently Used (LFU) cache. Implement the LFUCache class: LFUCache(int capacity) Initializes the object with the capacity of the data structure. int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1 . void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity , it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated. To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key. When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it. The functions get and put must each run in O(1) average time complexity. Ideas The class maintains a number of instance members to achieve the functions, capacity: the capacity of the LFU count: a mapping from key to count lookup: a lookup mapping from key to cached value keys: a double linked list that has all the keys in such a order that keys with lower count and recently used come first key_pointers: a dictionary with the format {key: [start_pointer, end_pointer]} , both start_pointer and end_pointer point to keys , and all the keys from start_pointer to end_pointer should have the same count When search for key, we just increase the count of the key by 1, remove it from the origin place in keys and insert it to the correct place in keys . When put a key value pair, we just increase the count of key by 1. If the number of key already excceeds the capacity, we need to evict the least recent used key that has the lowest count. During the whole process, we need to manage these instance members carefully. Solution class Node : def __init__ ( self , val = 0 , prev = None , next = None ): self . val = val self . prev = prev self . next = next class LFUCache : def __init__ ( self , capacity : int ): self . capacity = capacity self . count = dict () self . lookup = dict () self . key_pointers = dict () self . keys = Node () def get ( self , key : int ) -> int : if key not in self . lookup : return - 1 self . _increase_count ( key ) return self . lookup [ key ] def put ( self , key : int , value : int ) -> None : if key not in self . lookup : if len ( self . lookup ) >= self . capacity : self . _evict_key () self . _increase_count ( key ) if len ( self . lookup ) < self . capacity or key in self . lookup : self . lookup [ key ] = value def _increase_count ( self , key : int ) -> None : if key in self . count : key_count = self . count [ key ] tail = self . key_pointers [ key_count ][ 1 ] # link the new node new_node = Node ( key , tail , tail . next ) tail . next = new_node if new_node . next : new_node . next . prev = new_node if key_count + 1 not in self . key_pointers : self . key_pointers [ key_count + 1 ] = [ new_node , new_node ] else : self . key_pointers [ key_count + 1 ][ 0 ] = new_node # search from tail forwards, delete the node with value key current_node = tail while current_node is not None and current_node . val != key : current_node = current_node . prev if current_node is not None : head , tail = self . key_pointers [ key_count ] if head is tail : del self . key_pointers [ key_count ] elif current_node is head : self . key_pointers [ key_count ][ 0 ] = head . next elif current_node is tail : self . key_pointers [ key_count ][ 1 ] = tail . prev current_node . prev . next = current_node . next current_node . next . prev = current_node . prev self . count [ key ] = key_count + 1 else : new_node = Node ( key , self . keys , self . keys . next ) self . keys . next = new_node if new_node . next is not None : new_node . next . prev = new_node if 1 not in self . key_pointers : self . key_pointers [ 1 ] = [ new_node , new_node ] else : self . key_pointers [ 1 ][ 0 ] = new_node self . count [ key ] = 1 def _evict_key ( self ) -> None : if self . keys . next is not None : lowest_count = self . count [ self . keys . next . val ] key_to_evict = self . key_pointers [ lowest_count ][ 1 ] if key_to_evict . prev is self . keys : del self . key_pointers [ lowest_count ] else : self . key_pointers [ lowest_count ][ 1 ] = key_to_evict . prev del self . lookup [ key_to_evict . val ] del self . count [ key_to_evict . val ] if key_to_evict . next is not None : key_to_evict . next . prev = key_to_evict . prev key_to_evict . prev . next = key_to_evict . next # Your LFUCache object will be instantiated and called as such: # obj = LFUCache(capacity) # param_1 = obj.get(key) # obj.put(key,value)","title":"460. LFU Cache"},{"location":"Leetcode/Data%20Structure/460.%20LFU%20Cache/#question","text":"Design and implement a data structure for a Least Frequently Used (LFU) cache. Implement the LFUCache class: LFUCache(int capacity) Initializes the object with the capacity of the data structure. int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1 . void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity , it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated. To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key. When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it. The functions get and put must each run in O(1) average time complexity.","title":"Question"},{"location":"Leetcode/Data%20Structure/460.%20LFU%20Cache/#ideas","text":"The class maintains a number of instance members to achieve the functions, capacity: the capacity of the LFU count: a mapping from key to count lookup: a lookup mapping from key to cached value keys: a double linked list that has all the keys in such a order that keys with lower count and recently used come first key_pointers: a dictionary with the format {key: [start_pointer, end_pointer]} , both start_pointer and end_pointer point to keys , and all the keys from start_pointer to end_pointer should have the same count When search for key, we just increase the count of the key by 1, remove it from the origin place in keys and insert it to the correct place in keys . When put a key value pair, we just increase the count of key by 1. If the number of key already excceeds the capacity, we need to evict the least recent used key that has the lowest count. During the whole process, we need to manage these instance members carefully.","title":"Ideas"},{"location":"Leetcode/Data%20Structure/460.%20LFU%20Cache/#solution","text":"class Node : def __init__ ( self , val = 0 , prev = None , next = None ): self . val = val self . prev = prev self . next = next class LFUCache : def __init__ ( self , capacity : int ): self . capacity = capacity self . count = dict () self . lookup = dict () self . key_pointers = dict () self . keys = Node () def get ( self , key : int ) -> int : if key not in self . lookup : return - 1 self . _increase_count ( key ) return self . lookup [ key ] def put ( self , key : int , value : int ) -> None : if key not in self . lookup : if len ( self . lookup ) >= self . capacity : self . _evict_key () self . _increase_count ( key ) if len ( self . lookup ) < self . capacity or key in self . lookup : self . lookup [ key ] = value def _increase_count ( self , key : int ) -> None : if key in self . count : key_count = self . count [ key ] tail = self . key_pointers [ key_count ][ 1 ] # link the new node new_node = Node ( key , tail , tail . next ) tail . next = new_node if new_node . next : new_node . next . prev = new_node if key_count + 1 not in self . key_pointers : self . key_pointers [ key_count + 1 ] = [ new_node , new_node ] else : self . key_pointers [ key_count + 1 ][ 0 ] = new_node # search from tail forwards, delete the node with value key current_node = tail while current_node is not None and current_node . val != key : current_node = current_node . prev if current_node is not None : head , tail = self . key_pointers [ key_count ] if head is tail : del self . key_pointers [ key_count ] elif current_node is head : self . key_pointers [ key_count ][ 0 ] = head . next elif current_node is tail : self . key_pointers [ key_count ][ 1 ] = tail . prev current_node . prev . next = current_node . next current_node . next . prev = current_node . prev self . count [ key ] = key_count + 1 else : new_node = Node ( key , self . keys , self . keys . next ) self . keys . next = new_node if new_node . next is not None : new_node . next . prev = new_node if 1 not in self . key_pointers : self . key_pointers [ 1 ] = [ new_node , new_node ] else : self . key_pointers [ 1 ][ 0 ] = new_node self . count [ key ] = 1 def _evict_key ( self ) -> None : if self . keys . next is not None : lowest_count = self . count [ self . keys . next . val ] key_to_evict = self . key_pointers [ lowest_count ][ 1 ] if key_to_evict . prev is self . keys : del self . key_pointers [ lowest_count ] else : self . key_pointers [ lowest_count ][ 1 ] = key_to_evict . prev del self . lookup [ key_to_evict . val ] del self . count [ key_to_evict . val ] if key_to_evict . next is not None : key_to_evict . next . prev = key_to_evict . prev key_to_evict . prev . next = key_to_evict . next # Your LFUCache object will be instantiated and called as such: # obj = LFUCache(capacity) # param_1 = obj.get(key) # obj.put(key,value)","title":"Solution"},{"location":"Leetcode/Data%20Structure/622.%20Design%20Circular%20Queue/","text":"Question Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called \"Ring Buffer\". One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Implementation the MyCircularQueue class: MyCircularQueue(k) Initializes the object with the size of the queue to be k. int Front() Gets the front item from the queue. If the queue is empty, return -1. int Rear() Gets the last item from the queue. If the queue is empty, return -1. boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful. boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful. boolean isEmpty() Checks whether the circular queue is empty or not. boolean isFull() Checks whether the circular queue is full or not. You must solve the problem without using the built-in queue data structure in your programming language. Ideas Using an array to mimic the circular linked list. Solutions class MyCircularQueue : def __init__ ( self , k : int ): self . queue = [ None ] * ( k + 1 ) self . head = self . tail = 0 def enQueue ( self , value : int ) -> bool : if self . isFull (): return False self . queue [ self . tail ] = value self . tail = ( self . tail + 1 ) % len ( self . queue ) return True def deQueue ( self ) -> bool : if self . isEmpty (): return False self . head = ( self . head + 1 ) % len ( self . queue ) return True def Front ( self ) -> int : if self . isEmpty (): return - 1 return self . queue [ self . head ] def Rear ( self ) -> int : if self . isEmpty (): return - 1 return self . queue [ self . tail - 1 ] def isEmpty ( self ) -> bool : return self . head == self . tail def isFull ( self ) -> bool : return ( self . tail + 1 ) % len ( self . queue ) == self . head # Your MyCircularQueue object will be instantiated and called as such: # obj = MyCircularQueue(k) # param_1 = obj.enQueue(value) # param_2 = obj.deQueue() # param_3 = obj.Front() # param_4 = obj.Rear() # param_5 = obj.isEmpty() # param_6 = obj.isFull()","title":"622. Design Circular Queue"},{"location":"Leetcode/Data%20Structure/622.%20Design%20Circular%20Queue/#question","text":"Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called \"Ring Buffer\". One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Implementation the MyCircularQueue class: MyCircularQueue(k) Initializes the object with the size of the queue to be k. int Front() Gets the front item from the queue. If the queue is empty, return -1. int Rear() Gets the last item from the queue. If the queue is empty, return -1. boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful. boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful. boolean isEmpty() Checks whether the circular queue is empty or not. boolean isFull() Checks whether the circular queue is full or not. You must solve the problem without using the built-in queue data structure in your programming language.","title":"Question"},{"location":"Leetcode/Data%20Structure/622.%20Design%20Circular%20Queue/#ideas","text":"Using an array to mimic the circular linked list.","title":"Ideas"},{"location":"Leetcode/Data%20Structure/622.%20Design%20Circular%20Queue/#solutions","text":"class MyCircularQueue : def __init__ ( self , k : int ): self . queue = [ None ] * ( k + 1 ) self . head = self . tail = 0 def enQueue ( self , value : int ) -> bool : if self . isFull (): return False self . queue [ self . tail ] = value self . tail = ( self . tail + 1 ) % len ( self . queue ) return True def deQueue ( self ) -> bool : if self . isEmpty (): return False self . head = ( self . head + 1 ) % len ( self . queue ) return True def Front ( self ) -> int : if self . isEmpty (): return - 1 return self . queue [ self . head ] def Rear ( self ) -> int : if self . isEmpty (): return - 1 return self . queue [ self . tail - 1 ] def isEmpty ( self ) -> bool : return self . head == self . tail def isFull ( self ) -> bool : return ( self . tail + 1 ) % len ( self . queue ) == self . head # Your MyCircularQueue object will be instantiated and called as such: # obj = MyCircularQueue(k) # param_1 = obj.enQueue(value) # param_2 = obj.deQueue() # param_3 = obj.Front() # param_4 = obj.Rear() # param_5 = obj.isEmpty() # param_6 = obj.isFull()","title":"Solutions"},{"location":"Leetcode/Greedy/122.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/","text":"Question You are given an array prices where prices[i] is the price of a given stock on the i-th day. Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Ideas This one is simple. Just calculate the profit as you go through the prices array, add up the profit you would make every time the price goes up. Solution class Solution : def maxProfit ( self , prices : List [ int ]) -> int : profit = 0 for idx in range ( len ( prices ) - 1 ): profit += max ( 0 , prices [ idx + 1 ] - prices [ idx ]) return profit","title":"122. Best Time to Buy and Sell Stock II"},{"location":"Leetcode/Greedy/122.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/#question","text":"You are given an array prices where prices[i] is the price of a given stock on the i-th day. Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).","title":"Question"},{"location":"Leetcode/Greedy/122.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/#ideas","text":"This one is simple. Just calculate the profit as you go through the prices array, add up the profit you would make every time the price goes up.","title":"Ideas"},{"location":"Leetcode/Greedy/122.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/#solution","text":"class Solution : def maxProfit ( self , prices : List [ int ]) -> int : profit = 0 for idx in range ( len ( prices ) - 1 ): profit += max ( 0 , prices [ idx + 1 ] - prices [ idx ]) return profit","title":"Solution"},{"location":"Leetcode/Greedy/135.%20Candy/","text":"Question There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children. Ideas This can be done scanning through the array twice. One from left to right, and the second one from right to left. First initialize the candies array, all the children start with 1 candy. When scanning from left to right, if ratings[idx] < rating[idx + 1] , then set candies[idx + 1] as candies[idx] + 1 . When scanning from right to left, if rating[idx - 1] > rating[idx] , then set candies[idx - 1] as max(candies[idx - 1], candies[idx] + 1) . Assume that rating[i] < rating[i + 1] > rating[i + 2] , then candies[i + 1] = candies[i] + 1 . After the second scan, candies[i + 1] can only become larger, so the relative order between candies[i] and candies[i + 1] remains unchanged. Both time and space time complexity are just O(n). Solution class Solution : def candy ( self , ratings : List [ int ]) -> int : candies = [ 1 ] * len ( ratings ) for idx in range ( len ( ratings ) - 1 ): if ratings [ idx ] < ratings [ idx + 1 ]: candies [ idx + 1 ] = candies [ idx ] + 1 for idx in range ( len ( ratings ) - 1 , 0 , - 1 ): if ratings [ idx - 1 ] > ratings [ idx ]: candies [ idx - 1 ] = max ( candies [ idx - 1 ], candies [ idx ] + 1 ) return sum ( candies )","title":"135. Candy"},{"location":"Leetcode/Greedy/135.%20Candy/#question","text":"There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children.","title":"Question"},{"location":"Leetcode/Greedy/135.%20Candy/#ideas","text":"This can be done scanning through the array twice. One from left to right, and the second one from right to left. First initialize the candies array, all the children start with 1 candy. When scanning from left to right, if ratings[idx] < rating[idx + 1] , then set candies[idx + 1] as candies[idx] + 1 . When scanning from right to left, if rating[idx - 1] > rating[idx] , then set candies[idx - 1] as max(candies[idx - 1], candies[idx] + 1) . Assume that rating[i] < rating[i + 1] > rating[i + 2] , then candies[i + 1] = candies[i] + 1 . After the second scan, candies[i + 1] can only become larger, so the relative order between candies[i] and candies[i + 1] remains unchanged. Both time and space time complexity are just O(n).","title":"Ideas"},{"location":"Leetcode/Greedy/135.%20Candy/#solution","text":"class Solution : def candy ( self , ratings : List [ int ]) -> int : candies = [ 1 ] * len ( ratings ) for idx in range ( len ( ratings ) - 1 ): if ratings [ idx ] < ratings [ idx + 1 ]: candies [ idx + 1 ] = candies [ idx ] + 1 for idx in range ( len ( ratings ) - 1 , 0 , - 1 ): if ratings [ idx - 1 ] > ratings [ idx ]: candies [ idx - 1 ] = max ( candies [ idx - 1 ], candies [ idx ] + 1 ) return sum ( candies )","title":"Solution"},{"location":"Leetcode/Greedy/406.%20Queue%20Reconstruction%20by%20Height/","text":"Question You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi . Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue ( queue[0] is the person at the front of the queue). Ideas Becase for each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi , so where people with lower height stand doesn't matter for those who taller than him/her. In that case, we want to pre-sort these people so that tallest person at the head of the list. For those have the same height, they are sorted in ascending order based on k . Then just going through the sorted people array. For each person = [h, k] , we just insert it to index k in result array. The time complexity and space complexity are O(nlogn) and O(n) . Solution class Solution : def reconstructQueue ( self , people : List [ List [ int ]]) -> List [ List [ int ]]: sorted_people = sorted ( people , key = lambda p : ( - p [ 0 ], p [ 1 ])) res = list () for ppl in sorted_people : res . insert ( ppl [ 1 ], ppl ) return res","title":"406. Queue Reconstruction by Height"},{"location":"Leetcode/Greedy/406.%20Queue%20Reconstruction%20by%20Height/#question","text":"You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi . Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue ( queue[0] is the person at the front of the queue).","title":"Question"},{"location":"Leetcode/Greedy/406.%20Queue%20Reconstruction%20by%20Height/#ideas","text":"Becase for each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi , so where people with lower height stand doesn't matter for those who taller than him/her. In that case, we want to pre-sort these people so that tallest person at the head of the list. For those have the same height, they are sorted in ascending order based on k . Then just going through the sorted people array. For each person = [h, k] , we just insert it to index k in result array. The time complexity and space complexity are O(nlogn) and O(n) .","title":"Ideas"},{"location":"Leetcode/Greedy/406.%20Queue%20Reconstruction%20by%20Height/#solution","text":"class Solution : def reconstructQueue ( self , people : List [ List [ int ]]) -> List [ List [ int ]]: sorted_people = sorted ( people , key = lambda p : ( - p [ 0 ], p [ 1 ])) res = list () for ppl in sorted_people : res . insert ( ppl [ 1 ], ppl ) return res","title":"Solution"},{"location":"Leetcode/Greedy/435.%20Non-overlapping%20Intervals/","text":"Question Given an array of intervals intervals where intervals[i] = [starti, endi] , return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Ideas This question can be solved with greedy. Every time we pick some intervals, we always want the one that has the smallest end index. That simply means we have more space left, and we can keep more non-overlapping intervals. So we need to pre-sort the intervals based on the end index, and then go through the sorted intervals to decide which part should be kept. The running time would be O(nlogn) because the use of sorting, and we need O(n) extra memory space to keep the sorted intervals. Solution class Solution : def eraseOverlapIntervals ( self , intervals : List [ List [ int ]]) -> int : sorted_intervals = sorted ( intervals , key = lambda x : x [ 1 ]) upper_boundary = float ( '-inf' ) discard_intervals = 0 for start , end in sorted_intervals : if start >= upper_boundary : upper_boundary = end else : discard_intervals += 1 return discard_intervals","title":"435. Non overlapping Intervals"},{"location":"Leetcode/Greedy/435.%20Non-overlapping%20Intervals/#question","text":"Given an array of intervals intervals where intervals[i] = [starti, endi] , return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.","title":"Question"},{"location":"Leetcode/Greedy/435.%20Non-overlapping%20Intervals/#ideas","text":"This question can be solved with greedy. Every time we pick some intervals, we always want the one that has the smallest end index. That simply means we have more space left, and we can keep more non-overlapping intervals. So we need to pre-sort the intervals based on the end index, and then go through the sorted intervals to decide which part should be kept. The running time would be O(nlogn) because the use of sorting, and we need O(n) extra memory space to keep the sorted intervals.","title":"Ideas"},{"location":"Leetcode/Greedy/435.%20Non-overlapping%20Intervals/#solution","text":"class Solution : def eraseOverlapIntervals ( self , intervals : List [ List [ int ]]) -> int : sorted_intervals = sorted ( intervals , key = lambda x : x [ 1 ]) upper_boundary = float ( '-inf' ) discard_intervals = 0 for start , end in sorted_intervals : if start >= upper_boundary : upper_boundary = end else : discard_intervals += 1 return discard_intervals","title":"Solution"},{"location":"Leetcode/Greedy/452.%20Minimum%20Number%20of%20Arrows%20to%20Burst%20Balloons/","text":"Question There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with x_start and x_end bursts by an arrow shot at x if x_start \u2264 x \u2264 x_end . There is no limit to the number of arrows that can be shot. An arrow once shot keeps traveling up infinitely. Given an array points where points[i] = [x_start, x_end] , return the minimum number of arrows that must be shot to burst all balloons. Ideas This looks similar to the question that removes overlapping intervals. Similarly, we first need to sort the balloons' x-coordinates, with end index as key and start index as secondary key. From the sorted list, we get the first balloon, which has the smallest end index. We want an arrow to be shot at the end index of the first balloon, so that it can shoot as many ballons as possible. If you move the arrow any further to the right, the first ballon wouldn't be shot. Then, with the position of the first arrow confirmed, we can skip all the ballons that would be shot by this arrow. Until we have some ballon that it has start index greater than the arrow index, then we need to shot another arrow. So the time complexity would be O(nlogn) because of the presort, and we need O(n) extra memory space to keep the sorted ballons. Solutions class Solution : def findMinArrowShots ( self , points : List [ List [ int ]]) -> int : sorted_points = sorted ( points , key = lambda x : ( x [ 1 ], x [ 0 ])) total_arrow = 0 last_arrow = float ( '-inf' ) for start , end in sorted_points : if start > last_arrow : total_arrow += 1 last_arrow = end return total_arrow","title":"452. Minimum Number of Arrows to Burst Balloons"},{"location":"Leetcode/Greedy/452.%20Minimum%20Number%20of%20Arrows%20to%20Burst%20Balloons/#question","text":"There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with x_start and x_end bursts by an arrow shot at x if x_start \u2264 x \u2264 x_end . There is no limit to the number of arrows that can be shot. An arrow once shot keeps traveling up infinitely. Given an array points where points[i] = [x_start, x_end] , return the minimum number of arrows that must be shot to burst all balloons.","title":"Question"},{"location":"Leetcode/Greedy/452.%20Minimum%20Number%20of%20Arrows%20to%20Burst%20Balloons/#ideas","text":"This looks similar to the question that removes overlapping intervals. Similarly, we first need to sort the balloons' x-coordinates, with end index as key and start index as secondary key. From the sorted list, we get the first balloon, which has the smallest end index. We want an arrow to be shot at the end index of the first balloon, so that it can shoot as many ballons as possible. If you move the arrow any further to the right, the first ballon wouldn't be shot. Then, with the position of the first arrow confirmed, we can skip all the ballons that would be shot by this arrow. Until we have some ballon that it has start index greater than the arrow index, then we need to shot another arrow. So the time complexity would be O(nlogn) because of the presort, and we need O(n) extra memory space to keep the sorted ballons.","title":"Ideas"},{"location":"Leetcode/Greedy/452.%20Minimum%20Number%20of%20Arrows%20to%20Burst%20Balloons/#solutions","text":"class Solution : def findMinArrowShots ( self , points : List [ List [ int ]]) -> int : sorted_points = sorted ( points , key = lambda x : ( x [ 1 ], x [ 0 ])) total_arrow = 0 last_arrow = float ( '-inf' ) for start , end in sorted_points : if start > last_arrow : total_arrow += 1 last_arrow = end return total_arrow","title":"Solutions"},{"location":"Leetcode/Greedy/455.%20Assign%20Cookies/","text":"Question Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor g[i] , which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j] . If s[j] >= g[i] , we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number. Ideas It's kind of straightforward with greedy algorithm. We always want to feed the child with smallest greedy factor by choosing the cookie with smallest possible size. We use 2 heaps to keep children & cookies in memory for quickly fetching child or cookie with smallest greedy factor/size. So the extra memory space is O(|g| + |s|) . Analysing the time complexity, data copy and heapify take time O(|g| + |s|) . For coming up the way to distribute the cookies, the running time is O(log(|g|))+O(log(|g-1|))+...+O(log1)+O(log(|s|))+O(log(|s-1|))+...+O(log1) . To simplify, So the total running time would be O(log|g| + log|s|) . Solution import heapq class Solution : def findContentChildren ( self , g : List [ int ], s : List [ int ]) -> int : greedy = g [:] size = s [:] heapq . heapify ( greedy ) heapq . heapify ( size ) children_fed = 0 while len ( greedy ) > 0 and len ( size ) > 0 : while len ( size ) > 0 and size [ 0 ] < greedy [ 0 ]: heapq . heappop ( size ) if len ( size ) > 0 : children_fed += 1 heapq . heappop ( greedy ) heapq . heappop ( size ) return children_fed","title":"455. Assign Cookies"},{"location":"Leetcode/Greedy/455.%20Assign%20Cookies/#question","text":"Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor g[i] , which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j] . If s[j] >= g[i] , we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.","title":"Question"},{"location":"Leetcode/Greedy/455.%20Assign%20Cookies/#ideas","text":"It's kind of straightforward with greedy algorithm. We always want to feed the child with smallest greedy factor by choosing the cookie with smallest possible size. We use 2 heaps to keep children & cookies in memory for quickly fetching child or cookie with smallest greedy factor/size. So the extra memory space is O(|g| + |s|) . Analysing the time complexity, data copy and heapify take time O(|g| + |s|) . For coming up the way to distribute the cookies, the running time is O(log(|g|))+O(log(|g-1|))+...+O(log1)+O(log(|s|))+O(log(|s-1|))+...+O(log1) . To simplify, So the total running time would be O(log|g| + log|s|) .","title":"Ideas"},{"location":"Leetcode/Greedy/455.%20Assign%20Cookies/#solution","text":"import heapq class Solution : def findContentChildren ( self , g : List [ int ], s : List [ int ]) -> int : greedy = g [:] size = s [:] heapq . heapify ( greedy ) heapq . heapify ( size ) children_fed = 0 while len ( greedy ) > 0 and len ( size ) > 0 : while len ( size ) > 0 and size [ 0 ] < greedy [ 0 ]: heapq . heappop ( size ) if len ( size ) > 0 : children_fed += 1 heapq . heappop ( greedy ) heapq . heappop ( size ) return children_fed","title":"Solution"},{"location":"Leetcode/Greedy/605.%20Can%20Place%20Flowers/","text":"Question You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots. Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule. Ideas With greedy algorithm, we just need to scan the flowerbed from left to right, and plant a new flower when possible. At the end, we could know the count of total number of flowers that can be planted. The running time is obvious O(n), and it only needs constant extra memory space. Solution class Solution : def canPlaceFlowers ( self , flowerbed : List [ int ], n : int ) -> bool : last_planted_idx = - 2 for idx in range ( len ( flowerbed )): if flowerbed [ idx ] == 1 : # if this plot is already planted last_planted_idx = idx elif ( idx - last_planted_idx > 1 and ( idx == len ( flowerbed ) - 1 or flowerbed [ idx + 1 ] != 1 ) ): n -= 1 last_planted_idx = idx return n <= 0","title":"605. Can Place Flowers"},{"location":"Leetcode/Greedy/605.%20Can%20Place%20Flowers/#question","text":"You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots. Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.","title":"Question"},{"location":"Leetcode/Greedy/605.%20Can%20Place%20Flowers/#ideas","text":"With greedy algorithm, we just need to scan the flowerbed from left to right, and plant a new flower when possible. At the end, we could know the count of total number of flowers that can be planted. The running time is obvious O(n), and it only needs constant extra memory space.","title":"Ideas"},{"location":"Leetcode/Greedy/605.%20Can%20Place%20Flowers/#solution","text":"class Solution : def canPlaceFlowers ( self , flowerbed : List [ int ], n : int ) -> bool : last_planted_idx = - 2 for idx in range ( len ( flowerbed )): if flowerbed [ idx ] == 1 : # if this plot is already planted last_planted_idx = idx elif ( idx - last_planted_idx > 1 and ( idx == len ( flowerbed ) - 1 or flowerbed [ idx + 1 ] != 1 ) ): n -= 1 last_planted_idx = idx return n <= 0","title":"Solution"},{"location":"Leetcode/Greedy/763.%20Partition%20Labels/","text":"Question You are given a string s . We want to partition the string into as many parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts. Ideas Since all the same characters should be in one partition, so if a 's first appearance is a-start and its last appearance is a-end , then the substring s[a-start, ..., a-end] should be in one partition. Same for the other characters, we can have a range for each one of them. Then, the problem would be converted to merge intervals . The running time for getting those intervals would be O(n) , and there are at most 26 lowercase letters, so at most there are 26 intervals, the merging process takes constant time. In conclusion, the overall time complexity is O(n) . And the space complexity of O(1) . Solution class Solution : def partitionLabels ( self , s : str ) -> List [ int ]: intervals = dict () for idx , ch in enumerate ( s ): if ch in intervals : intervals [ ch ][ 1 ] = idx else : intervals [ ch ] = [ idx , idx ] intervals = sorted ( intervals . values (), key = lambda x : ( x [ 0 ], x [ 1 ])) # merge intervals current_interval = None result = [] for start , end in intervals : if current_interval is not None and start <= current_interval [ 1 ]: current_interval = ( min ( current_interval [ 0 ], start ), max ( current_interval [ 1 ], end ) ) else : if current_interval is not None : result . append ( current_interval [ 1 ] - current_interval [ 0 ] + 1 ) current_interval = ( start , end ) result . append ( current_interval [ 1 ] - current_interval [ 0 ] + 1 ) return result","title":"763. Partition Labels"},{"location":"Leetcode/Greedy/763.%20Partition%20Labels/#question","text":"You are given a string s . We want to partition the string into as many parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts.","title":"Question"},{"location":"Leetcode/Greedy/763.%20Partition%20Labels/#ideas","text":"Since all the same characters should be in one partition, so if a 's first appearance is a-start and its last appearance is a-end , then the substring s[a-start, ..., a-end] should be in one partition. Same for the other characters, we can have a range for each one of them. Then, the problem would be converted to merge intervals . The running time for getting those intervals would be O(n) , and there are at most 26 lowercase letters, so at most there are 26 intervals, the merging process takes constant time. In conclusion, the overall time complexity is O(n) . And the space complexity of O(1) .","title":"Ideas"},{"location":"Leetcode/Greedy/763.%20Partition%20Labels/#solution","text":"class Solution : def partitionLabels ( self , s : str ) -> List [ int ]: intervals = dict () for idx , ch in enumerate ( s ): if ch in intervals : intervals [ ch ][ 1 ] = idx else : intervals [ ch ] = [ idx , idx ] intervals = sorted ( intervals . values (), key = lambda x : ( x [ 0 ], x [ 1 ])) # merge intervals current_interval = None result = [] for start , end in intervals : if current_interval is not None and start <= current_interval [ 1 ]: current_interval = ( min ( current_interval [ 0 ], start ), max ( current_interval [ 1 ], end ) ) else : if current_interval is not None : result . append ( current_interval [ 1 ] - current_interval [ 0 ] + 1 ) current_interval = ( start , end ) result . append ( current_interval [ 1 ] - current_interval [ 0 ] + 1 ) return result","title":"Solution"},{"location":"Leetcode/Linked%20List/138.%20Copy%20List%20with%20Random%20Pointer/","text":"Question A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. Ideas The tricky part of the question is handling the random pointer. We can first just copy the list without worry about the random pointer, which is trivial. During the whole process, we can point the random pointer to the corresponding node in the origin list. And also, we can have a dictionary that maps the nodes in origin list to corresponding nodes in new list. After that, let's then deal with the random pointer. Note that the new nodes' random pointers are pointing to old nodes, and with the dictionary, we can find the node that the random pointer is supposed to pointing to. Assume the new node is n, then we have # n.random is pointing to corresponding node in # origin list, so the n.random is supposed to # point to dict[n.random.random] n = dict [ n . random . random ] It's obvious that the time complexity is O(n) , since we just need to scan the list twice. And the space complexity is O(1) , excluding the memory taken by the new list that is going to returned. Solution \"\"\" # Definition for a Node. class Node: def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None): self.val = int(x) self.next = next self.random = random \"\"\" class Solution : def copyRandomList ( self , head : 'Node' ) -> 'Node' : new_head = None prev_node = None current_node = head old_new_node_map = dict () while current_node is not None : node = Node ( current_node . val , None , current_node ) old_new_node_map [ id ( current_node )] = node if new_head is None : new_head = node if prev_node is not None : prev_node . next = node prev_node = node current_node = current_node . next current_node = new_head while current_node is not None : if current_node . random . random is not None : # if the origin node's random pointer is not None current_node . random = old_new_node_map [ id ( current_node . random . random )] else : current_node . random = None current_node = current_node . next return new_head","title":"138. Copy List with Random Pointer"},{"location":"Leetcode/Linked%20List/138.%20Copy%20List%20with%20Random%20Pointer/#question","text":"A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.","title":"Question"},{"location":"Leetcode/Linked%20List/138.%20Copy%20List%20with%20Random%20Pointer/#ideas","text":"The tricky part of the question is handling the random pointer. We can first just copy the list without worry about the random pointer, which is trivial. During the whole process, we can point the random pointer to the corresponding node in the origin list. And also, we can have a dictionary that maps the nodes in origin list to corresponding nodes in new list. After that, let's then deal with the random pointer. Note that the new nodes' random pointers are pointing to old nodes, and with the dictionary, we can find the node that the random pointer is supposed to pointing to. Assume the new node is n, then we have # n.random is pointing to corresponding node in # origin list, so the n.random is supposed to # point to dict[n.random.random] n = dict [ n . random . random ] It's obvious that the time complexity is O(n) , since we just need to scan the list twice. And the space complexity is O(1) , excluding the memory taken by the new list that is going to returned.","title":"Ideas"},{"location":"Leetcode/Linked%20List/138.%20Copy%20List%20with%20Random%20Pointer/#solution","text":"\"\"\" # Definition for a Node. class Node: def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None): self.val = int(x) self.next = next self.random = random \"\"\" class Solution : def copyRandomList ( self , head : 'Node' ) -> 'Node' : new_head = None prev_node = None current_node = head old_new_node_map = dict () while current_node is not None : node = Node ( current_node . val , None , current_node ) old_new_node_map [ id ( current_node )] = node if new_head is None : new_head = node if prev_node is not None : prev_node . next = node prev_node = node current_node = current_node . next current_node = new_head while current_node is not None : if current_node . random . random is not None : # if the origin node's random pointer is not None current_node . random = old_new_node_map [ id ( current_node . random . random )] else : current_node . random = None current_node = current_node . next return new_head","title":"Solution"},{"location":"Leetcode/Linked%20List/143.%20Reorder%20List/","text":"Question You are given the head of a singly linked-list. The list can be represented as: L[0] \u2192 L[1] \u2192 \u2026 \u2192 L[n - 1] \u2192 L[n] Reorder the list to be on the following form: L[0] \u2192 L[n] \u2192 L[1] \u2192 L[n - 1] \u2192 L[2] \u2192 L[n - 2] \u2192 \u2026 You may not modify the values in the list's nodes. Only nodes themselves may be changed. Ideas find the middle point of the list with slow and fast pointers reverse the second half of the list merge the first half and the reversed second part The time and space complexity are O(n) and O(1) . Solution # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def reorderList ( self , head : ListNode ) -> None : \"\"\" Do not return anything, modify head in-place instead. \"\"\" if head : mid = self . getMiddle ( head ) reverse , _ = self . reverse ( mid ) self . merge ( head , reverse ) def reverse ( self , head ): if head is None : return None , None if head . next is None : return head , head h , t = self . reverse ( head . next ) t . next , head . next = head , None return h , head def getMiddle ( self , head ): if head is None : return None slow = fast = head while fast . next and fast . next . next : slow = slow . next fast = fast . next . next mid = slow . next slow . next = None return mid def merge ( self , l1 , l2 ): while l1 and l2 : l1_tmp = l1 . next l2_tmp = l2 . next l1 . next = l2 l1 = l1_tmp l2 . next = l1 l2 = l2_tmp","title":"143. Reorder List"},{"location":"Leetcode/Linked%20List/143.%20Reorder%20List/#question","text":"You are given the head of a singly linked-list. The list can be represented as: L[0] \u2192 L[1] \u2192 \u2026 \u2192 L[n - 1] \u2192 L[n] Reorder the list to be on the following form: L[0] \u2192 L[n] \u2192 L[1] \u2192 L[n - 1] \u2192 L[2] \u2192 L[n - 2] \u2192 \u2026 You may not modify the values in the list's nodes. Only nodes themselves may be changed.","title":"Question"},{"location":"Leetcode/Linked%20List/143.%20Reorder%20List/#ideas","text":"find the middle point of the list with slow and fast pointers reverse the second half of the list merge the first half and the reversed second part The time and space complexity are O(n) and O(1) .","title":"Ideas"},{"location":"Leetcode/Linked%20List/143.%20Reorder%20List/#solution","text":"# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def reorderList ( self , head : ListNode ) -> None : \"\"\" Do not return anything, modify head in-place instead. \"\"\" if head : mid = self . getMiddle ( head ) reverse , _ = self . reverse ( mid ) self . merge ( head , reverse ) def reverse ( self , head ): if head is None : return None , None if head . next is None : return head , head h , t = self . reverse ( head . next ) t . next , head . next = head , None return h , head def getMiddle ( self , head ): if head is None : return None slow = fast = head while fast . next and fast . next . next : slow = slow . next fast = fast . next . next mid = slow . next slow . next = None return mid def merge ( self , l1 , l2 ): while l1 and l2 : l1_tmp = l1 . next l2_tmp = l2 . next l1 . next = l2 l1 = l1_tmp l2 . next = l1 l2 = l2_tmp","title":"Solution"},{"location":"Leetcode/Linked%20List/237.%20Delete%20Node%20in%20a%20Linked%20List/","text":"Question Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly. It is guaranteed that the node to be deleted is not a tail node in the list. Ideas Since the given node is not a tail node, and we have no access to its parent node. A work around is to copy its next node's value to current node, and delete the next one instead. Solution # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution : def deleteNode ( self , node ): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" node . val = node . next . val node . next = node . next . next","title":"237. Delete Node in a Linked List"},{"location":"Leetcode/Linked%20List/237.%20Delete%20Node%20in%20a%20Linked%20List/#question","text":"Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly. It is guaranteed that the node to be deleted is not a tail node in the list.","title":"Question"},{"location":"Leetcode/Linked%20List/237.%20Delete%20Node%20in%20a%20Linked%20List/#ideas","text":"Since the given node is not a tail node, and we have no access to its parent node. A work around is to copy its next node's value to current node, and delete the next one instead.","title":"Ideas"},{"location":"Leetcode/Linked%20List/237.%20Delete%20Node%20in%20a%20Linked%20List/#solution","text":"# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution : def deleteNode ( self , node ): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" node . val = node . next . val node . next = node . next . next","title":"Solution"},{"location":"Leetcode/Linked%20List/25.%20Reverse%20Nodes%20in%20k-Group/","text":"Question Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed. Ideas The idea is trivial. We can define a helper function, it first count if there are at least k nodes in the list, if there are at least k nodes, it just get the first k nodes from the linked list, reverse the list. Then call the method recursively on the rest part if no, it just return the list as it is The running time is O(n) , and the space complexity is O(1) . To make it even faster, we can reverse the first k nodes when we are counting. But need to reverse it again if we find out that there are less than k nodes in the list. In this way, the order of time complexity doesn't change, but it's roughly halved. Solution # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def reverseKGroup ( self , head : ListNode , k : int ) -> ListNode : def helper ( head , k ): first_section_head = None first_section_tail = head current_node = head nodes_in_first_sec = 0 while nodes_in_first_sec < k and current_node is not None : # reverse the first k nodes as we go tmp = current_node current_node = current_node . next tmp . next = first_section_head first_section_head = tmp nodes_in_first_sec += 1 if current_node is None : if nodes_in_first_sec == k : return first_section_head , first_section_tail else : # reverse it back return reverse ( first_section_head ) else : h , t = helper ( current_node , k ) first_section_tail . next = h return first_section_head , t def reverse ( head ): if head is None : return None , None if head . next is None : return head , head h , t = reverse ( head . next ) t . next = head head . next = None return h , head new_head , _ = helper ( head , k ) return new_head","title":"25. Reverse Nodes in k Group"},{"location":"Leetcode/Linked%20List/25.%20Reverse%20Nodes%20in%20k-Group/#question","text":"Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed.","title":"Question"},{"location":"Leetcode/Linked%20List/25.%20Reverse%20Nodes%20in%20k-Group/#ideas","text":"The idea is trivial. We can define a helper function, it first count if there are at least k nodes in the list, if there are at least k nodes, it just get the first k nodes from the linked list, reverse the list. Then call the method recursively on the rest part if no, it just return the list as it is The running time is O(n) , and the space complexity is O(1) . To make it even faster, we can reverse the first k nodes when we are counting. But need to reverse it again if we find out that there are less than k nodes in the list. In this way, the order of time complexity doesn't change, but it's roughly halved.","title":"Ideas"},{"location":"Leetcode/Linked%20List/25.%20Reverse%20Nodes%20in%20k-Group/#solution","text":"# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def reverseKGroup ( self , head : ListNode , k : int ) -> ListNode : def helper ( head , k ): first_section_head = None first_section_tail = head current_node = head nodes_in_first_sec = 0 while nodes_in_first_sec < k and current_node is not None : # reverse the first k nodes as we go tmp = current_node current_node = current_node . next tmp . next = first_section_head first_section_head = tmp nodes_in_first_sec += 1 if current_node is None : if nodes_in_first_sec == k : return first_section_head , first_section_tail else : # reverse it back return reverse ( first_section_head ) else : h , t = helper ( current_node , k ) first_section_tail . next = h return first_section_head , t def reverse ( head ): if head is None : return None , None if head . next is None : return head , head h , t = reverse ( head . next ) t . next = head head . next = None return h , head new_head , _ = helper ( head , k ) return new_head","title":"Solution"},{"location":"Leetcode/Linked%20List/328.%20Odd%20Even%20Linked%20List/","text":"Question Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The first node is considered odd, and the second node is even, and so on. Note that the relative order inside both the even and odd groups should remain as it was in the input. You must solve the problem in O(1) extra space complexity and O(n) time complexity. Ideas Scan the list, put elements in odd and even positions to different lists Link the even list at the end of the odd list Solution # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def oddEvenList ( self , head : ListNode ) -> ListNode : odd_even_lists = [[ ListNode (), None ], [ ListNode (), None ]] odd_even_lists [ 0 ][ 1 ] = odd_even_lists [ 0 ][ 0 ] odd_even_lists [ 1 ][ 1 ] = odd_even_lists [ 1 ][ 0 ] current_node = head list_to_append = 0 while current_node is not None : tmp = current_node current_node = current_node . next tmp . next = None odd_even_lists [ list_to_append ][ 1 ] . next = tmp odd_even_lists [ list_to_append ][ 1 ] = tmp list_to_append = 1 - list_to_append odd_even_lists [ 0 ][ 1 ] . next = odd_even_lists [ 1 ][ 0 ] . next return odd_even_lists [ 0 ][ 0 ] . next","title":"328. Odd Even Linked List"},{"location":"Leetcode/Linked%20List/328.%20Odd%20Even%20Linked%20List/#question","text":"Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The first node is considered odd, and the second node is even, and so on. Note that the relative order inside both the even and odd groups should remain as it was in the input. You must solve the problem in O(1) extra space complexity and O(n) time complexity.","title":"Question"},{"location":"Leetcode/Linked%20List/328.%20Odd%20Even%20Linked%20List/#ideas","text":"Scan the list, put elements in odd and even positions to different lists Link the even list at the end of the odd list","title":"Ideas"},{"location":"Leetcode/Linked%20List/328.%20Odd%20Even%20Linked%20List/#solution","text":"# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def oddEvenList ( self , head : ListNode ) -> ListNode : odd_even_lists = [[ ListNode (), None ], [ ListNode (), None ]] odd_even_lists [ 0 ][ 1 ] = odd_even_lists [ 0 ][ 0 ] odd_even_lists [ 1 ][ 1 ] = odd_even_lists [ 1 ][ 0 ] current_node = head list_to_append = 0 while current_node is not None : tmp = current_node current_node = current_node . next tmp . next = None odd_even_lists [ list_to_append ][ 1 ] . next = tmp odd_even_lists [ list_to_append ][ 1 ] = tmp list_to_append = 1 - list_to_append odd_even_lists [ 0 ][ 1 ] . next = odd_even_lists [ 1 ][ 0 ] . next return odd_even_lists [ 0 ][ 0 ] . next","title":"Solution"},{"location":"Leetcode/Linked%20List/426.%20Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List/","text":"Question Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place. You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element. We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list. Ideas Like tree traversal, we can use recursion. Write a helper function, first convert two substrees, than link those 2 linked lists with the root, and return the result list. The running time should just be O(n) where n refers to the total number of nodes in the tree. Solution \"\"\" # Definition for a Node. class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right \"\"\" class Solution : def treeToDoublyList ( self , root : 'Node' ) -> 'Node' : def helper ( root ): if root is None : return [ None , None ] head_left , tail_left = helper ( root . left ) head_right , tail_right = helper ( root . right ) head = root tail = root if head_left : tail_left . right = root root . left = tail_left head = head_left if head_right : head_right . left = root root . right = head_right tail = tail_right return head , tail h , t = helper ( root ) if h : h . left = t t . right = h return h","title":"426. Convert Binary Search Tree to Sorted Doubly Linked List"},{"location":"Leetcode/Linked%20List/426.%20Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List/#question","text":"Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place. You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element. We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.","title":"Question"},{"location":"Leetcode/Linked%20List/426.%20Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List/#ideas","text":"Like tree traversal, we can use recursion. Write a helper function, first convert two substrees, than link those 2 linked lists with the root, and return the result list. The running time should just be O(n) where n refers to the total number of nodes in the tree.","title":"Ideas"},{"location":"Leetcode/Linked%20List/426.%20Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List/#solution","text":"\"\"\" # Definition for a Node. class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right \"\"\" class Solution : def treeToDoublyList ( self , root : 'Node' ) -> 'Node' : def helper ( root ): if root is None : return [ None , None ] head_left , tail_left = helper ( root . left ) head_right , tail_right = helper ( root . right ) head = root tail = root if head_left : tail_left . right = root root . left = tail_left head = head_left if head_right : head_right . left = root root . right = head_right tail = tail_right return head , tail h , t = helper ( root ) if h : h . left = t t . right = h return h","title":"Solution"},{"location":"Leetcode/Linked%20List/445.%20Add%20Two%20Numbers%20II/","text":"Question You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Ideas reverse two given lists sum these two from the least significant digit reverse the result again and return Solution # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : def reverse ( head ): if head is None : return None , None if head . next is None : return head , head h , t = reverse ( head . next ) t . next = head head . next = None return h , head reversed_l1 , _ = reverse ( l1 ) reversed_l2 , _ = reverse ( l2 ) current_l1 = reversed_l1 current_l2 = reversed_l2 reversed_result = ListNode ( 0 ) current_result = reversed_result carry_over = 0 while current_l1 is not None or current_l2 is not None : tmp = ( ( 0 if current_l1 is None else current_l1 . val ) + ( 0 if current_l2 is None else current_l2 . val ) + carry_over ) current_result . next = ListNode ( tmp % 10 ) carry_over = tmp // 10 current_result = current_result . next current_l1 = None if current_l1 is None else current_l1 . next current_l2 = None if current_l2 is None else current_l2 . next if carry_over > 0 : current_result . next = ListNode ( carry_over ) result , _ = reverse ( reversed_result . next ) return result","title":"445. Add Two Numbers II"},{"location":"Leetcode/Linked%20List/445.%20Add%20Two%20Numbers%20II/#question","text":"You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.","title":"Question"},{"location":"Leetcode/Linked%20List/445.%20Add%20Two%20Numbers%20II/#ideas","text":"reverse two given lists sum these two from the least significant digit reverse the result again and return","title":"Ideas"},{"location":"Leetcode/Linked%20List/445.%20Add%20Two%20Numbers%20II/#solution","text":"# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : def reverse ( head ): if head is None : return None , None if head . next is None : return head , head h , t = reverse ( head . next ) t . next = head head . next = None return h , head reversed_l1 , _ = reverse ( l1 ) reversed_l2 , _ = reverse ( l2 ) current_l1 = reversed_l1 current_l2 = reversed_l2 reversed_result = ListNode ( 0 ) current_result = reversed_result carry_over = 0 while current_l1 is not None or current_l2 is not None : tmp = ( ( 0 if current_l1 is None else current_l1 . val ) + ( 0 if current_l2 is None else current_l2 . val ) + carry_over ) current_result . next = ListNode ( tmp % 10 ) carry_over = tmp // 10 current_result = current_result . next current_l1 = None if current_l1 is None else current_l1 . next current_l2 = None if current_l2 is None else current_l2 . next if carry_over > 0 : current_result . next = ListNode ( carry_over ) result , _ = reverse ( reversed_result . next ) return result","title":"Solution"},{"location":"Leetcode/Sliding%20Window/1004.%20Max%20Consecutive%20Ones%20III/","text":"Question Given a binary array nums and an integer k , return the maximum number of consecutive 1 's in the array if you can flip at most k 0 's. Ideas Can be solved with sliding window, keep tracking the number of zeros in the current window and shrink the window if necessary. It has O(n) time complexity and O(1) space complexity. Solution class Solution : def longestOnes ( self , nums : List [ int ], k : int ) -> int : left , max_ones , current_ones , max_length = 0 , 0 , 0 , 0 for right , right_num in enumerate ( nums ): if right_num == 1 : current_ones += 1 max_ones = max ( max_ones , current_ones ) if right - left + 1 - max_ones > k : if nums [ left ] == 1 : current_ones -= 1 left += max_length = max ( max_length , right - left + 1 ) return max_length","title":"1004. Max Consecutive Ones III"},{"location":"Leetcode/Sliding%20Window/1004.%20Max%20Consecutive%20Ones%20III/#question","text":"Given a binary array nums and an integer k , return the maximum number of consecutive 1 's in the array if you can flip at most k 0 's.","title":"Question"},{"location":"Leetcode/Sliding%20Window/1004.%20Max%20Consecutive%20Ones%20III/#ideas","text":"Can be solved with sliding window, keep tracking the number of zeros in the current window and shrink the window if necessary. It has O(n) time complexity and O(1) space complexity.","title":"Ideas"},{"location":"Leetcode/Sliding%20Window/1004.%20Max%20Consecutive%20Ones%20III/#solution","text":"class Solution : def longestOnes ( self , nums : List [ int ], k : int ) -> int : left , max_ones , current_ones , max_length = 0 , 0 , 0 , 0 for right , right_num in enumerate ( nums ): if right_num == 1 : current_ones += 1 max_ones = max ( max_ones , current_ones ) if right - left + 1 - max_ones > k : if nums [ left ] == 1 : current_ones -= 1 left += max_length = max ( max_length , right - left + 1 ) return max_length","title":"Solution"},{"location":"Leetcode/Sliding%20Window/30.%20Substring%20with%20Concatenation%20of%20All%20Words/","text":"Question You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters. You can return the answer in any order. Ideas Since each word should appear exactly the same times as in the given list. So all the matching substrings should have the same length. We can solve the problem with fixed size sliding window. We use a hash map to keep the words and frequencies in the list. For each window, we try to match the substring with the word in the list. And we can move to next substring if the word is not in the list, or the frequency is already larger than the frequency in the given list. The space complexity would be O(|words size|) , which is just the size of the hash map. For the time complexity, there are in total |s| - |words size| * |words number| sliding windows. For each sliding window, we try to match the substring, which would cause O(|words size| * |words number|) time. So the total run time would be O(|s| * |words size| * |words number|) . Solutions from collections import Counter class Solution : def sameCount ( self , count , targetCount ): for key in targetCount : if targetCount [ key ] != count [ key ]: return False return len ( count ) == len ( targetCount ) def findSubstring ( self , s : str , words : List [ str ]) -> List [ int ]: word_list_count = Counter () for word in words : word_list_count [ word ] += 1 word_len = len ( words [ 0 ]) word_nums = len ( words ) # sliding windows have fixed length start , end = 0 , word_len * word_nums - 1 result = list () while end < len ( s ): current_window_word_count = Counter () word_start = start while word_start <= end : word = s [ word_start : word_start + word_len ] if word not in word_list_count : break current_window_word_count [ word ] += 1 if current_window_word_count [ word ] > word_list_count [ word ]: break word_start += word_len else : if self . sameCount ( current_window_word_count , word_list_count ): result . append ( start ) start += 1 end += 1 return result","title":"30. Substring with Concatenation of All Words"},{"location":"Leetcode/Sliding%20Window/30.%20Substring%20with%20Concatenation%20of%20All%20Words/#question","text":"You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters. You can return the answer in any order.","title":"Question"},{"location":"Leetcode/Sliding%20Window/30.%20Substring%20with%20Concatenation%20of%20All%20Words/#ideas","text":"Since each word should appear exactly the same times as in the given list. So all the matching substrings should have the same length. We can solve the problem with fixed size sliding window. We use a hash map to keep the words and frequencies in the list. For each window, we try to match the substring with the word in the list. And we can move to next substring if the word is not in the list, or the frequency is already larger than the frequency in the given list. The space complexity would be O(|words size|) , which is just the size of the hash map. For the time complexity, there are in total |s| - |words size| * |words number| sliding windows. For each sliding window, we try to match the substring, which would cause O(|words size| * |words number|) time. So the total run time would be O(|s| * |words size| * |words number|) .","title":"Ideas"},{"location":"Leetcode/Sliding%20Window/30.%20Substring%20with%20Concatenation%20of%20All%20Words/#solutions","text":"from collections import Counter class Solution : def sameCount ( self , count , targetCount ): for key in targetCount : if targetCount [ key ] != count [ key ]: return False return len ( count ) == len ( targetCount ) def findSubstring ( self , s : str , words : List [ str ]) -> List [ int ]: word_list_count = Counter () for word in words : word_list_count [ word ] += 1 word_len = len ( words [ 0 ]) word_nums = len ( words ) # sliding windows have fixed length start , end = 0 , word_len * word_nums - 1 result = list () while end < len ( s ): current_window_word_count = Counter () word_start = start while word_start <= end : word = s [ word_start : word_start + word_len ] if word not in word_list_count : break current_window_word_count [ word ] += 1 if current_window_word_count [ word ] > word_list_count [ word ]: break word_start += word_len else : if self . sameCount ( current_window_word_count , word_list_count ): result . append ( start ) start += 1 end += 1 return result","title":"Solutions"},{"location":"Leetcode/Sliding%20Window/424.%20Longest%20Repeating%20Character%20Replacement/","text":"Question You are given a string s and an integer k . You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations. Ideas With sliding window pattern, we can use a hash map to keep all the character frequencies in the window, can keep track of the maxFrequency . If we can replace all the other characters with at most k operations. One thing to notice, While shrinking the window, we don\u2019t need to update maxFrequency . Even though current window's actual maxFrequency count might be smaller than the number we are tracking, but we know that in one of the previous windows, the actual max frequency count equals to the variable, and that window size is at most current window size. So we can still achieve the longest length by expanding that previous substring if necessary. Solution from collections import Counter class Solution : def characterReplacement ( self , s : str , k : int ) -> int : window_start , max_length , max_repeat_letter_count = 0 , 0 , 0 frequency_map = Counter () for window_end , right_char in enumerate ( s ): frequency_map [ right_char ] += 1 # in all the windows, there must be at least one window that # has max letter frequency equals to max_repeat_letter_count max_repeat_letter_count = max ( max_repeat_letter_count , frequency_map [ right_char ]) if ( window_end - window_start + 1 - max_repeat_letter_count ) > k : frequency_map [ s [ window_start ]] -= 1 # since everytime the window shrinks at most once # so current window size must be no smaller than # all previous windows window_start += 1 max_length = max ( max_length , window_end - window_start + 1 ) return max_length","title":"424. Longest Repeating Character Replacement"},{"location":"Leetcode/Sliding%20Window/424.%20Longest%20Repeating%20Character%20Replacement/#question","text":"You are given a string s and an integer k . You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations.","title":"Question"},{"location":"Leetcode/Sliding%20Window/424.%20Longest%20Repeating%20Character%20Replacement/#ideas","text":"With sliding window pattern, we can use a hash map to keep all the character frequencies in the window, can keep track of the maxFrequency . If we can replace all the other characters with at most k operations. One thing to notice, While shrinking the window, we don\u2019t need to update maxFrequency . Even though current window's actual maxFrequency count might be smaller than the number we are tracking, but we know that in one of the previous windows, the actual max frequency count equals to the variable, and that window size is at most current window size. So we can still achieve the longest length by expanding that previous substring if necessary.","title":"Ideas"},{"location":"Leetcode/Sliding%20Window/424.%20Longest%20Repeating%20Character%20Replacement/#solution","text":"from collections import Counter class Solution : def characterReplacement ( self , s : str , k : int ) -> int : window_start , max_length , max_repeat_letter_count = 0 , 0 , 0 frequency_map = Counter () for window_end , right_char in enumerate ( s ): frequency_map [ right_char ] += 1 # in all the windows, there must be at least one window that # has max letter frequency equals to max_repeat_letter_count max_repeat_letter_count = max ( max_repeat_letter_count , frequency_map [ right_char ]) if ( window_end - window_start + 1 - max_repeat_letter_count ) > k : frequency_map [ s [ window_start ]] -= 1 # since everytime the window shrinks at most once # so current window size must be no smaller than # all previous windows window_start += 1 max_length = max ( max_length , window_end - window_start + 1 ) return max_length","title":"Solution"},{"location":"Leetcode/Sliding%20Window/438.%20Find%20All%20Anagrams%20in%20a%20String/","text":"Question Given two strings s and p , return an array of all the start indices of p 's anagrams in s . You may return the answer in any order. Ideas Similar to question 567. Permutation in String . Instead of return True when we find a permutation, we just keep the start index along the way. The time and space complexities are still O(m + n) and O(1) . Solutions class Solution : def findAnagrams ( self , s : str , p : str ) -> List [ int ]: if len ( p ) > len ( s ): return [] word_diff = dict () combined = p + s left , right = 0 , len ( p ) res = list () while right < len ( combined ): if combined [ left ] in word_diff : word_diff [ combined [ left ]] -= 1 if word_diff [ combined [ left ]] == 0 : del word_diff [ combined [ left ]] else : word_diff [ combined [ left ]] = - 1 if combined [ right ] in word_diff : word_diff [ combined [ right ]] += 1 if word_diff [ combined [ right ]] == 0 : del word_diff [ combined [ right ]] else : word_diff [ combined [ right ]] = 1 if left + 1 >= len ( p ) and len ( word_diff ) == 0 : res . append ( left + 1 - len ( p )) left += 1 right += 1 return res","title":"438. Find All Anagrams in a String"},{"location":"Leetcode/Sliding%20Window/438.%20Find%20All%20Anagrams%20in%20a%20String/#question","text":"Given two strings s and p , return an array of all the start indices of p 's anagrams in s . You may return the answer in any order.","title":"Question"},{"location":"Leetcode/Sliding%20Window/438.%20Find%20All%20Anagrams%20in%20a%20String/#ideas","text":"Similar to question 567. Permutation in String . Instead of return True when we find a permutation, we just keep the start index along the way. The time and space complexities are still O(m + n) and O(1) .","title":"Ideas"},{"location":"Leetcode/Sliding%20Window/438.%20Find%20All%20Anagrams%20in%20a%20String/#solutions","text":"class Solution : def findAnagrams ( self , s : str , p : str ) -> List [ int ]: if len ( p ) > len ( s ): return [] word_diff = dict () combined = p + s left , right = 0 , len ( p ) res = list () while right < len ( combined ): if combined [ left ] in word_diff : word_diff [ combined [ left ]] -= 1 if word_diff [ combined [ left ]] == 0 : del word_diff [ combined [ left ]] else : word_diff [ combined [ left ]] = - 1 if combined [ right ] in word_diff : word_diff [ combined [ right ]] += 1 if word_diff [ combined [ right ]] == 0 : del word_diff [ combined [ right ]] else : word_diff [ combined [ right ]] = 1 if left + 1 >= len ( p ) and len ( word_diff ) == 0 : res . append ( left + 1 - len ( p )) left += 1 right += 1 return res","title":"Solutions"},{"location":"Leetcode/Sliding%20Window/567.%20Permutation%20in%20String/","text":"Question Given two strings s1 and s2 , return true if s2 contains the permutation of s1 . In other words, one of s1 's permutations is the substring of s2 . Ideas Follow the sliding window pattern, we can combine the pattern s1 and text s2 , then we know that in the combined text, the first s1.length characters form a permutation (it's just s1 itself). Everytime, we just slide this fixed size window one position at a time, keep track of the character difference with a hash map. If we find some window that has no character difference and doesn't include the first s1.length characters (the origin s1 ), then we can claim that we found a permutation. So the time complexity would be O(m + n) . As for space complexity, since s1 and s2 have only lowercase English letters, it would just be O(1) . Solution class Solution : def checkInclusion ( self , s1 : str , s2 : str ) -> bool : if len ( s1 ) > len ( s2 ): return False word_diff = dict () combined = s1 + s2 left , right = 0 , len ( s1 ) while right < len ( combined ): if combined [ left ] in word_diff : word_diff [ combined [ left ]] -= 1 if word_diff [ combined [ left ]] == 0 : del word_diff [ combined [ left ]] else : word_diff [ combined [ left ]] = - 1 if combined [ right ] in word_diff : word_diff [ combined [ right ]] += 1 if word_diff [ combined [ right ]] == 0 : del word_diff [ combined [ right ]] else : word_diff [ combined [ right ]] = 1 if left + 1 >= len ( s1 ) and len ( word_diff ) == 0 : return True left += 1 right += 1 return False","title":"567. Permutation in String"},{"location":"Leetcode/Sliding%20Window/567.%20Permutation%20in%20String/#question","text":"Given two strings s1 and s2 , return true if s2 contains the permutation of s1 . In other words, one of s1 's permutations is the substring of s2 .","title":"Question"},{"location":"Leetcode/Sliding%20Window/567.%20Permutation%20in%20String/#ideas","text":"Follow the sliding window pattern, we can combine the pattern s1 and text s2 , then we know that in the combined text, the first s1.length characters form a permutation (it's just s1 itself). Everytime, we just slide this fixed size window one position at a time, keep track of the character difference with a hash map. If we find some window that has no character difference and doesn't include the first s1.length characters (the origin s1 ), then we can claim that we found a permutation. So the time complexity would be O(m + n) . As for space complexity, since s1 and s2 have only lowercase English letters, it would just be O(1) .","title":"Ideas"},{"location":"Leetcode/Sliding%20Window/567.%20Permutation%20in%20String/#solution","text":"class Solution : def checkInclusion ( self , s1 : str , s2 : str ) -> bool : if len ( s1 ) > len ( s2 ): return False word_diff = dict () combined = s1 + s2 left , right = 0 , len ( s1 ) while right < len ( combined ): if combined [ left ] in word_diff : word_diff [ combined [ left ]] -= 1 if word_diff [ combined [ left ]] == 0 : del word_diff [ combined [ left ]] else : word_diff [ combined [ left ]] = - 1 if combined [ right ] in word_diff : word_diff [ combined [ right ]] += 1 if word_diff [ combined [ right ]] == 0 : del word_diff [ combined [ right ]] else : word_diff [ combined [ right ]] = 1 if left + 1 >= len ( s1 ) and len ( word_diff ) == 0 : return True left += 1 right += 1 return False","title":"Solution"},{"location":"Leetcode/Sliding%20Window/713.%20Subarray%20Product%20Less%20Than%20K/","text":"Question Given an array of integers nums and an integer k , return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k . Ideas This follows the sliding window pattern. In each iteration, we increase the right index by 1, and shrink the left index if the product of current subarray is too large. When we find such a subarray, we increase the count by rightIdx - leftIdx + 1 , this is all the subarrays that end at rightIdx and have product less than k . For example the array is [10,5,2,6] and k is 100. left, right=> 10 5 2 6 count is added by 1, the subarray here is [10] left=>10 right=> 5 2 6 count is added by 2, the subarrays are [10, 5], [5] 10 left=>5 right=> 2 6 count is added by 2, the subarrays are [2, 6], [6] 10 left=>5 2 right=> 6 count is added by 3, the subarrays are [5, 2, 6], [2, 6], [6] The running time here is O(n) and it only needs constant extra memory. Solutions class Solution { public : int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { int totalCount = 0 ; int leftIdx = 0 ; int windowProduct = 1 ; for ( int rightIdx = 0 ; rightIdx < nums . size (); rightIdx ++ ) { windowProduct *= nums [ rightIdx ]; while ( leftIdx <= rightIdx & windowProduct >= k ) { windowProduct /= nums [ leftIdx ++ ]; } totalCount += ( rightIdx - leftIdx + 1 ); } return totalCount ; } };","title":"713. Subarray Product Less Than K"},{"location":"Leetcode/Sliding%20Window/713.%20Subarray%20Product%20Less%20Than%20K/#question","text":"Given an array of integers nums and an integer k , return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k .","title":"Question"},{"location":"Leetcode/Sliding%20Window/713.%20Subarray%20Product%20Less%20Than%20K/#ideas","text":"This follows the sliding window pattern. In each iteration, we increase the right index by 1, and shrink the left index if the product of current subarray is too large. When we find such a subarray, we increase the count by rightIdx - leftIdx + 1 , this is all the subarrays that end at rightIdx and have product less than k . For example the array is [10,5,2,6] and k is 100. left, right=> 10 5 2 6 count is added by 1, the subarray here is [10] left=>10 right=> 5 2 6 count is added by 2, the subarrays are [10, 5], [5] 10 left=>5 right=> 2 6 count is added by 2, the subarrays are [2, 6], [6] 10 left=>5 2 right=> 6 count is added by 3, the subarrays are [5, 2, 6], [2, 6], [6] The running time here is O(n) and it only needs constant extra memory.","title":"Ideas"},{"location":"Leetcode/Sliding%20Window/713.%20Subarray%20Product%20Less%20Than%20K/#solutions","text":"class Solution { public : int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { int totalCount = 0 ; int leftIdx = 0 ; int windowProduct = 1 ; for ( int rightIdx = 0 ; rightIdx < nums . size (); rightIdx ++ ) { windowProduct *= nums [ rightIdx ]; while ( leftIdx <= rightIdx & windowProduct >= k ) { windowProduct /= nums [ leftIdx ++ ]; } totalCount += ( rightIdx - leftIdx + 1 ); } return totalCount ; } };","title":"Solutions"},{"location":"Leetcode/Two%20Pointers/16.%203Sum%20Closest/","text":"Question Given an array nums of n integers and an integer target , find three integers in nums such that the sum is closest to target . Return the sum of the three integers. You may assume that each input would have exactly one solution. Ideas Similar to the 3 sum question, instead of finding the triple that has sum equals to target , we keep the triple that has sum closest to target. The space complexity would be O(1) and run time would be O(n^2) . Solutions class Solution : def threeSumClosest ( self , arr : List [ int ], target_sum : int ) -> int : sorted_num = sorted ( arr ) total_sum = float ( 'inf' ) for first_idx in range ( len ( sorted_num ) - 2 ): left = first_idx + 1 right = len ( sorted_num ) - 1 while left < right : current_sum = sorted_num [ first_idx ] + sorted_num [ left ] + sorted_num [ right ] if ( abs ( current_sum - target_sum ) < abs ( total_sum - target_sum ) or ( abs ( current_sum - target_sum ) == abs ( total_sum - target_sum ) and current_sum < total_sum ) ): total_sum = current_sum if current_sum < target_sum : left += 1 elif current_sum > target_sum : right -= 1 else : return current_sum return total_sum","title":"16. 3Sum Closest"},{"location":"Leetcode/Two%20Pointers/16.%203Sum%20Closest/#question","text":"Given an array nums of n integers and an integer target , find three integers in nums such that the sum is closest to target . Return the sum of the three integers. You may assume that each input would have exactly one solution.","title":"Question"},{"location":"Leetcode/Two%20Pointers/16.%203Sum%20Closest/#ideas","text":"Similar to the 3 sum question, instead of finding the triple that has sum equals to target , we keep the triple that has sum closest to target. The space complexity would be O(1) and run time would be O(n^2) .","title":"Ideas"},{"location":"Leetcode/Two%20Pointers/16.%203Sum%20Closest/#solutions","text":"class Solution : def threeSumClosest ( self , arr : List [ int ], target_sum : int ) -> int : sorted_num = sorted ( arr ) total_sum = float ( 'inf' ) for first_idx in range ( len ( sorted_num ) - 2 ): left = first_idx + 1 right = len ( sorted_num ) - 1 while left < right : current_sum = sorted_num [ first_idx ] + sorted_num [ left ] + sorted_num [ right ] if ( abs ( current_sum - target_sum ) < abs ( total_sum - target_sum ) or ( abs ( current_sum - target_sum ) == abs ( total_sum - target_sum ) and current_sum < total_sum ) ): total_sum = current_sum if current_sum < target_sum : left += 1 elif current_sum > target_sum : right -= 1 else : return current_sum return total_sum","title":"Solutions"},{"location":"Leetcode/Two%20Pointers/26.%20Remove%20Duplicates%20from%20Sorted%20Array/","text":"Question Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums . More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums . Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Ideas Since the array is non-decreasing, all the duplicate numbers are placed next to each other. We could have two pointers, read and write , starting from 0. The read pointer will skip the number if it finds that the number is the same as the next number. Otherwise it writes the number to the position that write pointer points to. r,w-> 2 3 3 3 6 9 9 2 r,w-> 3 3 3 6 9 9 2 w-> 3 r-> 3 3 6 9 9 2 w-> 3 3 r-> 3 6 9 9 2 3 w-> 3 3 r-> 6 9 9 2 3 6 w-> 3 6 r-> 9 9 2 3 6 w-> 3 6 9 r-> 9 2 3 6 9 w-> 6 9 9 r-> Now, all the numbers without duplications are put in the first four places, and write pointer pointing to position 4, which is just the length of the non-duplication array. Solution class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : read , write = 0 , 0 while read < len ( nums ): if read == len ( nums ) - 1 or nums [ read ] != nums [ read + 1 ]: nums [ write ] = nums [ read ] write += 1 read += 1 return write","title":"26. Remove Duplicates from Sorted Array"},{"location":"Leetcode/Two%20Pointers/26.%20Remove%20Duplicates%20from%20Sorted%20Array/#question","text":"Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums . More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums . Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.","title":"Question"},{"location":"Leetcode/Two%20Pointers/26.%20Remove%20Duplicates%20from%20Sorted%20Array/#ideas","text":"Since the array is non-decreasing, all the duplicate numbers are placed next to each other. We could have two pointers, read and write , starting from 0. The read pointer will skip the number if it finds that the number is the same as the next number. Otherwise it writes the number to the position that write pointer points to. r,w-> 2 3 3 3 6 9 9 2 r,w-> 3 3 3 6 9 9 2 w-> 3 r-> 3 3 6 9 9 2 w-> 3 3 r-> 3 6 9 9 2 3 w-> 3 3 r-> 6 9 9 2 3 6 w-> 3 6 r-> 9 9 2 3 6 w-> 3 6 9 r-> 9 2 3 6 9 w-> 6 9 9 r-> Now, all the numbers without duplications are put in the first four places, and write pointer pointing to position 4, which is just the length of the non-duplication array.","title":"Ideas"},{"location":"Leetcode/Two%20Pointers/26.%20Remove%20Duplicates%20from%20Sorted%20Array/#solution","text":"class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : read , write = 0 , 0 while read < len ( nums ): if read == len ( nums ) - 1 or nums [ read ] != nums [ read + 1 ]: nums [ write ] = nums [ read ] write += 1 read += 1 return write","title":"Solution"},{"location":"Leetcode/Two%20Pointers/75.%20Sort%20Colors/","text":"Question Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0 , 1 , and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function. Ideas We use an index pointing to the first element indicating where 1 should start, and an index pointing to the last element indicating where 1 should end. And with a read index, we can scan the whole array. At any point, from 0 to firstOneIdx are all the 0 s, from firstOneIdx to read are all the 1 s, and from lastOneIdx to the end are all the 2 s. So we can put all the numbers in place with just one scan. The time complexity would be O(n) and it only requires constant extra memory. Solution class Solution { public : void sortColors ( vector < int >& nums ) { int firstOneIdx = 0 ; int lastOneIdx = nums . size () - 1 ; int read = 0 ; while ( read <= lastOneIdx ) { if ( nums [ read ] == 0 ) { int tmp = nums [ firstOneIdx ]; nums [ firstOneIdx ++ ] = nums [ read ]; nums [ read ] = tmp ; read ++ ; } else if ( nums [ read ] == 2 ) { int tmp = nums [ lastOneIdx ]; nums [ lastOneIdx -- ] = nums [ read ]; nums [ read ] = tmp ; } else { read ++ ; } } } };","title":"75. Sort Colors"},{"location":"Leetcode/Two%20Pointers/75.%20Sort%20Colors/#question","text":"Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0 , 1 , and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function.","title":"Question"},{"location":"Leetcode/Two%20Pointers/75.%20Sort%20Colors/#ideas","text":"We use an index pointing to the first element indicating where 1 should start, and an index pointing to the last element indicating where 1 should end. And with a read index, we can scan the whole array. At any point, from 0 to firstOneIdx are all the 0 s, from firstOneIdx to read are all the 1 s, and from lastOneIdx to the end are all the 2 s. So we can put all the numbers in place with just one scan. The time complexity would be O(n) and it only requires constant extra memory.","title":"Ideas"},{"location":"Leetcode/Two%20Pointers/75.%20Sort%20Colors/#solution","text":"class Solution { public : void sortColors ( vector < int >& nums ) { int firstOneIdx = 0 ; int lastOneIdx = nums . size () - 1 ; int read = 0 ; while ( read <= lastOneIdx ) { if ( nums [ read ] == 0 ) { int tmp = nums [ firstOneIdx ]; nums [ firstOneIdx ++ ] = nums [ read ]; nums [ read ] = tmp ; read ++ ; } else if ( nums [ read ] == 2 ) { int tmp = nums [ lastOneIdx ]; nums [ lastOneIdx -- ] = nums [ read ]; nums [ read ] = tmp ; } else { read ++ ; } } } };","title":"Solution"},{"location":"Leetcode/Two%20Pointers/977.%20Squares%20of%20a%20Sorted%20Array/","text":"Question Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. Ideas We can have a lo pointer that points to the first element and a hi pointer that points to the last element. While lo pointer is no greater than hi pointer, we pick the one that has higher absolute value, which means larger square value. We keep iterating until lo and hi meet at the center. The runtime would be O(n) and space complexity would be O(1) . Solution class Solution : def sortedSquares ( self , nums : List [ int ]) -> List [ int ]: res = [ 0 ] * len ( nums ) lo , hi , write = 0 , len ( nums ) - 1 , len ( nums ) - 1 while lo <= hi : if abs ( nums [ lo ]) >= abs ( nums [ hi ]): res [ write ] = pow ( nums [ lo ], 2 ) lo += 1 else : res [ write ] = pow ( nums [ hi ], 2 ) hi -= 1 write -= 1 return res","title":"977. Squares of a Sorted Array"},{"location":"Leetcode/Two%20Pointers/977.%20Squares%20of%20a%20Sorted%20Array/#question","text":"Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.","title":"Question"},{"location":"Leetcode/Two%20Pointers/977.%20Squares%20of%20a%20Sorted%20Array/#ideas","text":"We can have a lo pointer that points to the first element and a hi pointer that points to the last element. While lo pointer is no greater than hi pointer, we pick the one that has higher absolute value, which means larger square value. We keep iterating until lo and hi meet at the center. The runtime would be O(n) and space complexity would be O(1) .","title":"Ideas"},{"location":"Leetcode/Two%20Pointers/977.%20Squares%20of%20a%20Sorted%20Array/#solution","text":"class Solution : def sortedSquares ( self , nums : List [ int ]) -> List [ int ]: res = [ 0 ] * len ( nums ) lo , hi , write = 0 , len ( nums ) - 1 , len ( nums ) - 1 while lo <= hi : if abs ( nums [ lo ]) >= abs ( nums [ hi ]): res [ write ] = pow ( nums [ lo ], 2 ) lo += 1 else : res [ write ] = pow ( nums [ hi ], 2 ) hi -= 1 write -= 1 return res","title":"Solution"}]}